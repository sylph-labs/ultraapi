pub mod openapi;

use axum::Router;
use axum::http::StatusCode;
use axum::response::{IntoResponse, Response};
use serde::Serialize;
use std::any::{Any, TypeId};
use std::collections::HashMap;
use std::sync::Arc;

// Re-exports
pub use hayai_macros::{get, post, put, delete, api_model};
pub use serde;
pub use serde_json;
pub use schemars;
pub use inventory;
pub use axum;

pub mod prelude {
    pub use crate::{get, post, put, delete, api_model};
    pub use crate::{HayaiApp, Dep, ApiError, Validate};
}

/// Validation trait generated by api_model attribute
pub trait Validate {
    fn validate(&self) -> Result<(), Vec<String>>;
}

/// Blanket impl for types without validation
impl Validate for () {
    fn validate(&self) -> Result<(), Vec<String>> {
        Ok(())
    }
}

/// Trait for schema patches from validation attributes
pub trait HasSchemaPatches {
    fn patch_schema(props: &mut HashMap<String, openapi::PropertyPatch>);
}

/// Application state holding dependency injection container
#[derive(Clone)]
pub struct AppState {
    deps: Arc<HashMap<TypeId, Arc<dyn Any + Send + Sync>>>,
}

impl AppState {
    pub fn new() -> Self {
        Self {
            deps: Arc::new(HashMap::new()),
        }
    }
    
    pub fn get<T: 'static + Send + Sync>(&self) -> Option<Arc<T>> {
        self.deps
            .get(&TypeId::of::<T>())
            .and_then(|v| v.clone().downcast::<T>().ok())
    }
}

/// Dependency injection extractor
pub struct Dep<T: 'static + Send + Sync>(Arc<T>);

impl<T: 'static + Send + Sync> Dep<T> {
    pub fn from_app_state(state: &AppState) -> Self {
        let arc = state.get::<T>().expect("Dependency not registered");
        Dep(arc)
    }
}

impl<T: 'static + Send + Sync> std::ops::Deref for Dep<T> {
    type Target = T;
    fn deref(&self) -> &T {
        &self.0
    }
}

/// API Error type
#[derive(Debug, Serialize)]
pub struct ApiError {
    #[serde(skip)]
    pub status: StatusCode,
    pub error: String,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub details: Vec<String>,
}

impl ApiError {
    pub fn bad_request(msg: String) -> Self {
        Self { status: StatusCode::BAD_REQUEST, error: msg, details: vec![] }
    }
    
    pub fn not_found(msg: String) -> Self {
        Self { status: StatusCode::NOT_FOUND, error: msg, details: vec![] }
    }
    
    pub fn internal(msg: String) -> Self {
        Self { status: StatusCode::INTERNAL_SERVER_ERROR, error: msg, details: vec![] }
    }
    
    pub fn validation_error(errors: Vec<String>) -> Self {
        Self {
            status: StatusCode::UNPROCESSABLE_ENTITY,
            error: "Validation failed".into(),
            details: errors,
        }
    }
}

impl IntoResponse for ApiError {
    fn into_response(self) -> Response {
        let body = serde_json::to_string(&self)
            .unwrap_or_else(|_| r#"{"error":"Internal server error"}"#.to_string());
        (self.status, [("content-type", "application/json")], body).into_response()
    }
}

/// Route information collected by proc macros
pub struct RouteInfo {
    pub path: &'static str,
    pub axum_path: &'static str,
    pub method: &'static str,
    pub handler_name: &'static str,
    pub response_type_name: &'static str,
    pub parameters: &'static [openapi::Parameter],
    pub has_body: bool,
    pub body_type_name: &'static str,
    pub register_fn: fn(Router<AppState>) -> Router<AppState>,
}

inventory::collect!(RouteInfo);

/// Schema information collected by api_model attribute
pub struct SchemaInfo {
    pub name: &'static str,
    pub schema_fn: fn() -> openapi::Schema,
}

inventory::collect!(SchemaInfo);

/// The main application struct
pub struct HayaiApp {
    deps: HashMap<TypeId, Arc<dyn Any + Send + Sync>>,
    title: String,
    version: String,
    swagger_cdn_url: Option<String>,
}

impl HayaiApp {
    pub fn new() -> Self {
        Self {
            deps: HashMap::new(),
            title: env!("CARGO_PKG_NAME").to_string(),
            version: env!("CARGO_PKG_VERSION").to_string(),
            swagger_cdn_url: None,
        }
    }
    
    pub fn title(mut self, title: &str) -> Self {
        self.title = title.to_string();
        self
    }
    
    pub fn version(mut self, version: &str) -> Self {
        self.version = version.to_string();
        self
    }
    
    pub fn swagger_cdn(mut self, url: &str) -> Self {
        self.swagger_cdn_url = Some(url.to_string());
        self
    }
    
    pub fn dep<T: 'static + Send + Sync>(mut self, dep: T) -> Self {
        self.deps.insert(TypeId::of::<T>(), Arc::new(dep));
        self
    }
    
    /// Build the configured Router without starting the server.
    /// Useful for testing or custom serving setups.
    pub fn into_router(self) -> Router {
        let spec = self.generate_openapi_spec();
        let swagger_html = self.generate_swagger_html();
        
        let state = AppState {
            deps: Arc::new(self.deps),
        };
        let spec_json = serde_json::to_string_pretty(&spec.to_json())
            .expect("Failed to serialize OpenAPI spec");
        
        let mut app = Router::new();
        
        // Auto-discover all routes from inventory
        for route in inventory::iter::<RouteInfo> {
            app = (route.register_fn)(app);
        }
        
        let spec_json_clone = spec_json.clone();
        app = app.route("/openapi.json", axum::routing::get(move || {
            let spec = spec_json_clone.clone();
            async move {
                (StatusCode::OK, [("content-type", "application/json")], spec)
            }
        }));
        
        app = app.route("/docs", axum::routing::get(move || {
            let html = swagger_html.clone();
            async move {
                (StatusCode::OK, [("content-type", "text/html")], html)
            }
        }));
        
        app.with_state(state)
    }

    pub async fn serve(self, addr: &str) {
        let app = self.into_router();
        
        let listener = tokio::net::TcpListener::bind(addr).await
            .expect("Failed to bind to address");
        println!("ðŸš€ Hayai server running at http://{}", addr);
        println!("ðŸ“– Swagger UI available at http://{}/docs", addr);
        axum::serve(listener, app).await
            .expect("Server error");
    }
    
    fn generate_swagger_html(&self) -> String {
        let cdn_base = self.swagger_cdn_url.as_deref()
            .unwrap_or("https://unpkg.com/swagger-ui-dist@5");
        format!(
            r#"<!DOCTYPE html>
<html>
<head>
    <title>{title} - Swagger UI</title>
    <link rel="stylesheet" type="text/css" href="{cdn}/swagger-ui.css" >
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="{cdn}/swagger-ui-bundle.js"> </script>
    <script>
    SwaggerUIBundle({{
        url: "/openapi.json",
        dom_id: '#swagger-ui',
        presets: [SwaggerUIBundle.presets.apis, SwaggerUIBundle.SwaggerUIStandalonePreset],
        layout: "BaseLayout"
    }})
    </script>
</body>
</html>"#,
            title = self.title,
            cdn = cdn_base,
        )
    }
    
    fn generate_openapi_spec(&self) -> openapi::OpenApiSpec {
        let mut schemas = HashMap::new();
        for info in inventory::iter::<SchemaInfo> {
            schemas.insert(info.name.to_string(), (info.schema_fn)());
        }
        
        let mut paths = HashMap::new();
        for route in inventory::iter::<RouteInfo> {
            let operation = openapi::Operation {
                summary: Some(route.handler_name.replace('_', " ")),
                operation_id: Some(route.handler_name.to_string()),
                parameters: route.parameters.to_vec(),
                request_body: if route.has_body {
                    Some(openapi::RequestBody {
                        required: true,
                        content_type: "application/json".to_string(),
                        schema_ref: format!("#/components/schemas/{}", route.body_type_name),
                    })
                } else {
                    None
                },
                responses: {
                    let mut map = HashMap::new();
                    map.insert("200".to_string(), openapi::ResponseDef {
                        description: "Successful response".to_string(),
                        schema_ref: Some(format!("#/components/schemas/{}", route.response_type_name)),
                    });
                    map
                },
            };
            
            let path_item = paths.entry(route.path.to_string()).or_insert_with(HashMap::new);
            path_item.insert(route.method.to_lowercase(), operation);
        }
        
        openapi::OpenApiSpec {
            openapi: "3.1.0".to_string(),
            info: openapi::Info {
                title: self.title.clone(),
                version: self.version.clone(),
            },
            paths,
            schemas,
        }
    }
}
