pub mod openapi;

use axum::Router;
use axum::http::StatusCode;
use axum::response::{IntoResponse, Response};
use serde::Serialize;
use std::any::{Any, TypeId};
use std::collections::HashMap;
use std::sync::Arc;

// Re-exports
pub use hayai_macros::{get, post, put, delete, api_model};
pub use serde;
pub use serde_json;
pub use schemars;
pub use inventory;
pub use axum;

pub mod prelude {
    pub use crate::{get, post, put, delete, api_model};
    pub use crate::{HayaiApp, Dep, ApiError, Validate};
    pub use crate::axum::extract::Query;
}

/// Validation trait generated by api_model attribute
pub trait Validate {
    fn validate(&self) -> Result<(), Vec<String>>;
}

impl Validate for () {
    fn validate(&self) -> Result<(), Vec<String>> {
        Ok(())
    }
}

/// Trait for schema patches from validation attributes
pub trait HasSchemaPatches {
    fn patch_schema(props: &mut HashMap<String, openapi::PropertyPatch>);
}

/// Application state holding dependency injection container
#[derive(Clone)]
pub struct AppState {
    deps: Arc<HashMap<TypeId, Arc<dyn Any + Send + Sync>>>,
}

impl AppState {
    pub fn new() -> Self {
        Self { deps: Arc::new(HashMap::new()) }
    }

    pub fn get<T: 'static + Send + Sync>(&self) -> Option<Arc<T>> {
        self.deps
            .get(&TypeId::of::<T>())
            .and_then(|v| v.clone().downcast::<T>().ok())
    }
}

/// Dependency injection extractor
pub struct Dep<T: 'static + Send + Sync>(Arc<T>);

impl<T: 'static + Send + Sync> Dep<T> {
    pub fn from_app_state(state: &AppState) -> Self {
        let arc = state.get::<T>().expect("Dependency not registered");
        Dep(arc)
    }
}

impl<T: 'static + Send + Sync> std::ops::Deref for Dep<T> {
    type Target = T;
    fn deref(&self) -> &T {
        &self.0
    }
}

/// API Error type
#[derive(Debug, Serialize)]
pub struct ApiError {
    #[serde(skip)]
    pub status: StatusCode,
    pub error: String,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub details: Vec<String>,
}

impl ApiError {
    pub fn bad_request(msg: String) -> Self {
        Self { status: StatusCode::BAD_REQUEST, error: msg, details: vec![] }
    }

    pub fn not_found(msg: String) -> Self {
        Self { status: StatusCode::NOT_FOUND, error: msg, details: vec![] }
    }

    pub fn internal(msg: String) -> Self {
        Self { status: StatusCode::INTERNAL_SERVER_ERROR, error: msg, details: vec![] }
    }

    pub fn validation_error(errors: Vec<String>) -> Self {
        Self {
            status: StatusCode::UNPROCESSABLE_ENTITY,
            error: "Validation failed".into(),
            details: errors,
        }
    }
}

impl IntoResponse for ApiError {
    fn into_response(self) -> Response {
        let body = serde_json::to_string(&self)
            .unwrap_or_else(|_| r#"{"error":"Internal server error"}"#.to_string());
        (self.status, [("content-type", "application/json")], body).into_response()
    }
}

/// Route information collected by proc macros
pub struct RouteInfo {
    pub path: &'static str,
    pub axum_path: &'static str,
    pub method: &'static str,
    pub handler_name: &'static str,
    pub response_type_name: &'static str,
    pub parameters: &'static [openapi::Parameter],
    pub has_body: bool,
    pub body_type_name: &'static str,
    pub success_status: u16,
    pub description: &'static str,
    pub tags: &'static [&'static str],
    pub query_params_fn: Option<fn() -> Vec<openapi::DynParameter>>,
    pub register_fn: fn(Router<AppState>) -> Router<AppState>,
}

inventory::collect!(RouteInfo);

/// Schema information collected by api_model attribute
pub struct SchemaInfo {
    pub name: &'static str,
    pub schema_fn: fn() -> openapi::Schema,
    pub nested_fn: fn() -> std::collections::HashMap<String, openapi::Schema>,
}

inventory::collect!(SchemaInfo);

/// The main application struct
pub struct HayaiApp {
    deps: HashMap<TypeId, Arc<dyn Any + Send + Sync>>,
    title: String,
    version: String,
    swagger_cdn_url: Option<String>,
}

impl HayaiApp {
    pub fn new() -> Self {
        Self {
            deps: HashMap::new(),
            title: env!("CARGO_PKG_NAME").to_string(),
            version: env!("CARGO_PKG_VERSION").to_string(),
            swagger_cdn_url: None,
        }
    }

    pub fn title(mut self, title: &str) -> Self {
        self.title = title.to_string();
        self
    }

    pub fn version(mut self, version: &str) -> Self {
        self.version = version.to_string();
        self
    }

    pub fn swagger_cdn(mut self, url: &str) -> Self {
        self.swagger_cdn_url = Some(url.to_string());
        self
    }

    pub fn dep<T: 'static + Send + Sync>(mut self, dep: T) -> Self {
        self.deps.insert(TypeId::of::<T>(), Arc::new(dep));
        self
    }

    pub fn into_router(self) -> Router {
        let spec = self.generate_openapi_spec();
        let swagger_html = self.generate_swagger_html();

        let state = AppState {
            deps: Arc::new(self.deps),
        };
        let spec_json = serde_json::to_string_pretty(&spec.to_json_with_query_params())
            .expect("Failed to serialize OpenAPI spec");

        let mut app = Router::new();

        for route in inventory::iter::<RouteInfo> {
            app = (route.register_fn)(app);
        }

        let spec_json_clone = spec_json.clone();
        app = app.route("/openapi.json", axum::routing::get(move || {
            let spec = spec_json_clone.clone();
            async move {
                (StatusCode::OK, [("content-type", "application/json")], spec)
            }
        }));

        app = app.route("/docs", axum::routing::get(move || {
            let html = swagger_html.clone();
            async move {
                (StatusCode::OK, [("content-type", "text/html")], html)
            }
        }));

        app.with_state(state)
    }

    pub async fn serve(self, addr: &str) {
        let app = self.into_router();

        let listener = tokio::net::TcpListener::bind(addr).await
            .expect("Failed to bind to address");
        println!("ðŸš€ Hayai server running at http://{}", addr);
        println!("ðŸ“– Swagger UI available at http://{}/docs", addr);
        axum::serve(listener, app).await
            .expect("Server error");
    }

    fn generate_swagger_html(&self) -> String {
        let cdn_base = self.swagger_cdn_url.as_deref()
            .unwrap_or("https://unpkg.com/swagger-ui-dist@5");
        format!(
            r#"<!DOCTYPE html>
<html>
<head>
    <title>{title} - Swagger UI</title>
    <link rel="stylesheet" type="text/css" href="{cdn}/swagger-ui.css" >
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="{cdn}/swagger-ui-bundle.js"> </script>
    <script>
    SwaggerUIBundle({{
        url: "/openapi.json",
        dom_id: '#swagger-ui',
        presets: [SwaggerUIBundle.presets.apis, SwaggerUIBundle.SwaggerUIStandalonePreset],
        layout: "BaseLayout"
    }})
    </script>
</body>
</html>"#,
            title = self.title,
            cdn = cdn_base,
        )
    }

    fn generate_openapi_spec(&self) -> openapi::OpenApiSpec {
        let mut schemas = HashMap::new();

        // Add ApiError schema
        schemas.insert("ApiError".to_string(), openapi::api_error_schema());

        for info in inventory::iter::<SchemaInfo> {
            schemas.insert(info.name.to_string(), (info.schema_fn)());
            for (nested_name, nested_schema) in (info.nested_fn)() {
                schemas.entry(nested_name).or_insert(nested_schema);
            }
        }

        let mut paths = HashMap::new();
        for route in inventory::iter::<RouteInfo> {
            let mut all_params: Vec<openapi::Parameter> = route.parameters.to_vec();

            // Combine query parameters
            let mut dyn_params = Vec::new();
            if let Some(qfn) = route.query_params_fn {
                dyn_params = qfn();
            }

            let description = if route.description.is_empty() {
                None
            } else {
                Some(route.description.to_string())
            };

            let tags: Vec<String> = route.tags.iter().map(|s| s.to_string()).collect();

            let status_code = route.success_status.to_string();

            let operation = openapi::Operation {
                summary: Some(route.handler_name.replace('_', " ")),
                description,
                operation_id: Some(route.handler_name.to_string()),
                tags,
                parameters: route.parameters.to_vec(),
                request_body: if route.has_body {
                    Some(openapi::RequestBody {
                        required: true,
                        content_type: "application/json".to_string(),
                        schema_ref: format!("#/components/schemas/{}", route.body_type_name),
                    })
                } else {
                    None
                },
                responses: {
                    let mut map = HashMap::new();

                    // Success response
                    let success_desc = match route.success_status {
                        201 => "Created",
                        204 => "No Content",
                        _ => "Successful response",
                    };
                    let schema_ref = if route.success_status == 204 {
                        None
                    } else {
                        Some(format!("#/components/schemas/{}", route.response_type_name))
                    };
                    map.insert(status_code, openapi::ResponseDef {
                        description: success_desc.to_string(),
                        schema_ref,
                    });

                    // Error responses
                    map.insert("400".to_string(), openapi::ResponseDef {
                        description: "Bad Request".to_string(),
                        schema_ref: Some("#/components/schemas/ApiError".to_string()),
                    });
                    if route.has_body {
                        map.insert("422".to_string(), openapi::ResponseDef {
                            description: "Validation Failed".to_string(),
                            schema_ref: Some("#/components/schemas/ApiError".to_string()),
                        });
                    }
                    map.insert("500".to_string(), openapi::ResponseDef {
                        description: "Internal Server Error".to_string(),
                        schema_ref: Some("#/components/schemas/ApiError".to_string()),
                    });

                    map
                },
            };

            // Merge dynamic query params into the operation
            // We need to serialize them alongside static params
            let path_item = paths.entry(route.path.to_string()).or_insert_with(HashMap::new);

            // If there are dynamic query params, we need to handle them
            if !dyn_params.is_empty() {
                let mut op = operation;
                // We'll add query params as a custom serialization step
                // For now, convert DynParameter to Parameter won't work due to &'static str
                // Instead, we'll handle this in the spec serialization
                // Actually, let's store them differently - use a wrapper
                path_item.insert(route.method.to_lowercase(), op);
                // We'll fix serialization to include dyn params
                // For now, let's use a different approach: store in a side map
            } else {
                path_item.insert(route.method.to_lowercase(), operation);
            }
        }

        // Second pass: inject dynamic query params into the JSON
        // Actually, let's build the spec properly by customizing to_json
        let mut spec = openapi::OpenApiSpec {
            openapi: "3.1.0".to_string(),
            info: openapi::Info {
                title: self.title.clone(),
                version: self.version.clone(),
            },
            paths,
            schemas,
        };

        // We need to patch query params into the spec JSON.
        // Let's store a side-channel for query params
        // Actually, the cleanest approach: store dyn params in Operation itself.
        // But Operation uses Vec<Parameter> with &'static str.
        // Let me just override to_json to handle this.

        spec
    }
}

// Store query param functions keyed by (path, method) for the JSON serialization
// This is a workaround for the static lifetime issue
thread_local! {
    static QUERY_PARAMS: std::cell::RefCell<HashMap<(String, String), Vec<openapi::DynParameter>>> =
        std::cell::RefCell::new(HashMap::new());
}

impl openapi::OpenApiSpec {
    /// Enhanced to_json that includes dynamic query parameters
    pub fn to_json_with_query_params(&self) -> serde_json::Value {
        let mut val = self.to_json();

        // Inject query params from RouteInfo
        for route in inventory::iter::<RouteInfo> {
            if let Some(qfn) = route.query_params_fn {
                let dyn_params = qfn();
                if !dyn_params.is_empty() {
                    let method = route.method.to_lowercase();
                    let path = route.path;
                    let escaped = path.replace('~', "~0").replace('/', "~1");
                    let pointer = format!("/paths/{}/{}", escaped, method);
                    if let Some(op) = val.pointer_mut(&pointer) {
                        let params = op.get("parameters")
                            .and_then(|v| v.as_array())
                            .cloned()
                            .unwrap_or_default();
                        let mut all_params = params;
                        for dp in &dyn_params {
                            all_params.push(serde_json::json!({
                                "name": dp.name,
                                "in": dp.location,
                                "required": dp.required,
                                "schema": { "type": dp.schema_type }
                            }));
                        }
                        op["parameters"] = serde_json::Value::Array(all_params);
                    }
                }
            }
        }

        val
    }
}
