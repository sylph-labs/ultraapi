pub mod openapi;

use axum::http::StatusCode;
use axum::response::{IntoResponse, Response};
use axum::Router;
use serde::Serialize;
use std::any::{Any, TypeId};
use std::collections::HashMap;
use std::sync::Arc;

// Re-exports
pub use axum;
pub use inventory;
pub use regex;
pub use schemars;
pub use serde;
pub use serde_json;
pub use ultraapi_macros::{api_model, delete, get, post, put};

pub mod prelude {
    pub use crate::axum::extract::Query;
    pub use crate::{api_model, delete, get, post, put};
    pub use crate::{ApiError, Dep, State, UltraApiApp, UltraApiRouter, Validate};
}

/// Validation trait generated by api_model attribute
pub trait Validate {
    fn validate(&self) -> Result<(), Vec<String>>;
}

impl Validate for () {
    fn validate(&self) -> Result<(), Vec<String>> {
        Ok(())
    }
}

#[async_trait::async_trait]
pub trait AsyncValidate: Send + Sync {
    async fn validate_async(&self, _state: &AppState) -> Result<(), Vec<String>> {
        Ok(())
    }
}

#[async_trait::async_trait]
impl AsyncValidate for () {
    async fn validate_async(&self, _state: &AppState) -> Result<(), Vec<String>> {
        Ok(())
    }
}

#[macro_export]
macro_rules! impl_async_validate {
    ($ty:ty, $sync_fn:ident) => {
        #[async_trait::async_trait]
        impl $crate::AsyncValidate for $ty {
            async fn validate_async(&self, _state: &$crate::AppState) -> Result<(), Vec<String>> {
                $sync_fn(self)
            }
        }
    };
}

/// Trait for schema patches from validation attributes
#[doc(hidden)]
pub trait HasSchemaPatches {
    fn patch_schema(props: &mut HashMap<String, openapi::PropertyPatch>);
}

/// Application state holding dependency injection container
#[derive(Clone)]
pub struct AppState {
    deps: Arc<HashMap<TypeId, Arc<dyn Any + Send + Sync>>>,
}

impl Default for AppState {
    fn default() -> Self {
        Self::new()
    }
}

impl AppState {
    pub fn new() -> Self {
        Self {
            deps: Arc::new(HashMap::new()),
        }
    }

    pub fn get<T: 'static + Send + Sync>(&self) -> Option<Arc<T>> {
        self.deps
            .get(&TypeId::of::<T>())
            .and_then(|v| v.clone().downcast::<T>().ok())
    }
}

/// Dependency injection extractor
pub struct Dep<T: 'static + Send + Sync>(Arc<T>);

impl<T: 'static + Send + Sync> Dep<T> {
    pub fn from_app_state(state: &AppState) -> Result<Self, ApiError> {
        state.get::<T>().map(Dep).ok_or_else(|| {
            ApiError::internal(format!(
                "Dependency not registered: {}",
                std::any::type_name::<T>()
            ))
        })
    }
}

impl<T: 'static + Send + Sync> std::ops::Deref for Dep<T> {
    type Target = T;
    fn deref(&self) -> &T {
        &self.0
    }
}

/// Axum-style state extractor â€” alternative to Dep<T>
/// Both work identically; choose based on your preferred style.
pub struct State<T: 'static + Send + Sync>(Arc<T>);

impl<T: 'static + Send + Sync> State<T> {
    pub fn from_app_state(state: &AppState) -> Result<Self, ApiError> {
        state.get::<T>().map(State).ok_or_else(|| {
            ApiError::internal(format!(
                "State not registered: {}",
                std::any::type_name::<T>()
            ))
        })
    }
}

impl<T: 'static + Send + Sync> std::ops::Deref for State<T> {
    type Target = T;
    fn deref(&self) -> &T {
        &self.0
    }
}

/// API Error type
#[derive(Debug, Serialize)]
pub struct ApiError {
    #[serde(skip)]
    pub status: StatusCode,
    pub error: String,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub details: Vec<String>,
}

impl ApiError {
    pub fn unauthorized(msg: impl Into<String>) -> Self {
        Self {
            status: StatusCode::UNAUTHORIZED,
            error: msg.into(),
            details: vec![],
        }
    }

    pub fn bad_request(msg: String) -> Self {
        Self {
            status: StatusCode::BAD_REQUEST,
            error: msg,
            details: vec![],
        }
    }

    pub fn not_found(msg: String) -> Self {
        Self {
            status: StatusCode::NOT_FOUND,
            error: msg,
            details: vec![],
        }
    }

    pub fn internal(msg: String) -> Self {
        Self {
            status: StatusCode::INTERNAL_SERVER_ERROR,
            error: msg,
            details: vec![],
        }
    }

    pub fn validation_error(errors: Vec<String>) -> Self {
        Self {
            status: StatusCode::UNPROCESSABLE_ENTITY,
            error: "Validation failed".into(),
            details: errors,
        }
    }
}

impl IntoResponse for ApiError {
    fn into_response(self) -> Response {
        let body = serde_json::to_string(&self)
            .unwrap_or_else(|_| r#"{"error":"Internal server error"}"#.to_string());
        (self.status, [("content-type", "application/json")], body).into_response()
    }
}

/// Route information collected by proc macros
pub struct RouteInfo {
    pub path: &'static str,
    pub axum_path: &'static str,
    pub method: &'static str,
    pub handler_name: &'static str,
    pub response_type_name: &'static str,
    pub is_result_return: bool,
    pub is_vec_response: bool,
    pub vec_inner_type_name: &'static str,
    pub parameters: &'static [openapi::Parameter],
    pub has_body: bool,
    pub body_type_name: &'static str,
    pub success_status: u16,
    pub description: &'static str,
    pub tags: &'static [&'static str],
    pub security: &'static [&'static str],
    pub query_params_fn: Option<fn() -> Vec<openapi::DynParameter>>,
    pub register_fn: fn(Router<AppState>) -> Router<AppState>,
    pub method_router_fn: fn() -> axum::routing::MethodRouter<AppState>,
}

inventory::collect!(&'static RouteInfo);

/// Schema information collected by api_model attribute
pub struct SchemaInfo {
    pub name: &'static str,
    pub schema_fn: fn() -> openapi::Schema,
    pub nested_fn: fn() -> std::collections::HashMap<String, openapi::Schema>,
}

inventory::collect!(SchemaInfo);

/// A resolved route with runtime prefix and merged tags/security
pub struct ResolvedRoute {
    pub route_info: &'static RouteInfo,
    pub prefix: String,
    pub extra_tags: Vec<String>,
    pub extra_security: Vec<String>,
}

impl ResolvedRoute {
    /// Full path = prefix + route's original path
    pub fn full_path(&self) -> String {
        let base = self.route_info.path;
        if self.prefix.is_empty() {
            base.to_string()
        } else {
            format!("{}{}", self.prefix, base)
        }
    }

    /// Full axum path = prefix + route's original axum_path
    pub fn full_axum_path(&self) -> String {
        let base = self.route_info.axum_path;
        if self.prefix.is_empty() {
            base.to_string()
        } else {
            format!("{}{}", self.prefix, base)
        }
    }

    /// Merged tags: router-level + route-level
    pub fn merged_tags(&self) -> Vec<String> {
        let mut tags: Vec<String> = self.extra_tags.clone();
        for t in self.route_info.tags {
            if !tags.contains(&t.to_string()) {
                tags.push(t.to_string());
            }
        }
        tags
    }

    /// Merged security: router-level + route-level
    pub fn merged_security(&self) -> Vec<&str> {
        let mut sec: Vec<&str> = self.extra_security.iter().map(|s| s.as_str()).collect();
        for s in self.route_info.security {
            if !sec.contains(s) {
                sec.push(s);
            }
        }
        sec
    }
}

/// A FastAPI-style router with prefix, shared tags, security, deps, and nested routers
pub struct UltraApiRouter {
    prefix: String,
    routes: Vec<&'static RouteInfo>,
    tags: Vec<String>,
    security: Vec<String>,
    deps: HashMap<TypeId, Arc<dyn Any + Send + Sync>>,
    children: Vec<UltraApiRouter>,
}

impl UltraApiRouter {
    pub fn new(prefix: &str) -> Self {
        Self {
            prefix: prefix.to_string(),
            routes: Vec::new(),
            tags: Vec::new(),
            security: Vec::new(),
            deps: HashMap::new(),
            children: Vec::new(),
        }
    }

    pub fn route(mut self, route: &'static RouteInfo) -> Self {
        self.routes.push(route);
        self
    }

    pub fn tag(mut self, tag: &str) -> Self {
        self.tags.push(tag.to_string());
        self
    }

    pub fn security(mut self, scheme: &str) -> Self {
        self.security.push(scheme.to_string());
        self
    }

    pub fn dep<T: 'static + Send + Sync>(mut self, dep: T) -> Self {
        self.deps.insert(TypeId::of::<T>(), Arc::new(dep));
        self
    }

    pub fn include(mut self, child: UltraApiRouter) -> Self {
        self.children.push(child);
        self
    }

    /// Flatten this router tree into resolved routes, accumulating prefix/tags/security
    pub fn resolve(
        &self,
        parent_prefix: &str,
        parent_tags: &[String],
        parent_security: &[String],
    ) -> Vec<ResolvedRoute> {
        let full_prefix = format!("{}{}", parent_prefix, self.prefix);
        let mut merged_tags: Vec<String> = parent_tags.to_vec();
        for t in &self.tags {
            if !merged_tags.contains(t) {
                merged_tags.push(t.clone());
            }
        }
        let mut merged_security: Vec<String> = parent_security.to_vec();
        for s in &self.security {
            if !merged_security.contains(s) {
                merged_security.push(s.clone());
            }
        }

        let mut resolved = Vec::new();
        for route in &self.routes {
            resolved.push(ResolvedRoute {
                route_info: route,
                prefix: full_prefix.clone(),
                extra_tags: merged_tags.clone(),
                extra_security: merged_security.clone(),
            });
        }
        for child in &self.children {
            resolved.extend(child.resolve(&full_prefix, &merged_tags, &merged_security));
        }
        resolved
    }

    /// Collect all deps from this router tree
    pub fn collect_deps(&self) -> HashMap<TypeId, Arc<dyn Any + Send + Sync>> {
        let mut all = self.deps.clone();
        for child in &self.children {
            all.extend(child.collect_deps());
        }
        all
    }
}

/// Swagger UI serving mode
#[derive(Debug, Clone)]
pub enum SwaggerMode {
    /// Load Swagger UI assets from a CDN URL
    Cdn(String),
    /// Use embedded Scalar API reference (works offline)
    Embedded,
}

/// The main application struct
pub struct UltraApiApp {
    deps: HashMap<TypeId, Arc<dyn Any + Send + Sync>>,
    /// Dependency overrides for testing - these take precedence over regular deps
    dep_overrides: HashMap<TypeId, Arc<dyn Any + Send + Sync>>,
    title: String,
    version: String,
    description: Option<String>,
    contact: Option<openapi::Contact>,
    license: Option<openapi::License>,
    swagger_mode: SwaggerMode,
    servers: Vec<openapi::Server>,
    security_schemes: HashMap<String, openapi::SecurityScheme>,
    routers: Vec<UltraApiRouter>,
}

impl Default for UltraApiApp {
    fn default() -> Self {
        Self::new()
    }
}

impl UltraApiApp {
    pub fn new() -> Self {
        Self {
            deps: HashMap::new(),
            dep_overrides: HashMap::new(),
            title: env!("CARGO_PKG_NAME").to_string(),
            version: env!("CARGO_PKG_VERSION").to_string(),
            description: None,
            contact: None,
            license: None,
            swagger_mode: SwaggerMode::Embedded,
            servers: Vec::new(),
            security_schemes: HashMap::new(),
            routers: Vec::new(),
        }
    }

    pub fn title(mut self, title: &str) -> Self {
        self.title = title.to_string();
        self
    }

    pub fn version(mut self, version: &str) -> Self {
        self.version = version.to_string();
        self
    }

    pub fn description(mut self, desc: &str) -> Self {
        self.description = Some(desc.to_string());
        self
    }

    pub fn contact(mut self, name: &str, email: &str, url: &str) -> Self {
        self.contact = Some(openapi::Contact {
            name: Some(name.to_string()),
            email: Some(email.to_string()),
            url: Some(url.to_string()),
        });
        self
    }

    pub fn license(mut self, name: &str, url: &str) -> Self {
        self.license = Some(openapi::License {
            name: name.to_string(),
            url: Some(url.to_string()),
        });
        self
    }

    pub fn swagger_mode(mut self, mode: SwaggerMode) -> Self {
        self.swagger_mode = mode;
        self
    }

    pub fn swagger_cdn(mut self, url: &str) -> Self {
        self.swagger_mode = SwaggerMode::Cdn(url.to_string());
        self
    }

    pub fn dep<T: 'static + Send + Sync>(mut self, dep: T) -> Self {
        self.deps.insert(TypeId::of::<T>(), Arc::new(dep));
        self
    }

    /// Override a dependency for testing.
    ///
    /// This allows replacing registered dependencies with mock values during testing.
    /// Overrides take precedence over regular dependencies registered via [`dep()`](UltraApiApp::dep).
    ///
    /// # Example
    ///
    /// ```ignore
    /// use ultraapi::{UltraApiApp, Dep};
    ///
    /// #[derive(Clone)]
    /// struct DatabasePool { /* ... */ }
    ///
    /// #[derive(Clone)]
    /// struct MockDatabase { pub data: Vec<String> }
    ///
    /// #[get("/items")]
    /// async fn get_items(dep(pool): Dep<DatabasePool>) -> Vec<String> {
    ///     vec![]
    /// }
    ///
    /// #[tokio::test]
    /// async fn test_with_mock_db() {
    ///     let mock_db = MockDatabase { data: vec!["test".into()] };
    ///
    ///     let app = UltraApiApp::new()
    ///         .dep(DatabasePool { /* real config */ })
    ///         .override_dep(mock_db)
    ///         .route(get_items);
    /// }
    /// ```
    pub fn override_dep<T: 'static + Send + Sync>(mut self, dep: T) -> Self {
        self.dep_overrides.insert(TypeId::of::<T>(), Arc::new(dep));
        self
    }

    /// Check if a dependency override exists for the given type.
    pub fn has_override<T: 'static + Send + Sync>(&self) -> bool {
        self.dep_overrides.contains_key(&TypeId::of::<T>())
    }

    /// Clear all dependency overrides.
    pub fn clear_overrides(mut self) -> Self {
        self.dep_overrides.clear();
        self
    }

    pub fn server(mut self, url: &str) -> Self {
        self.servers.push(openapi::Server {
            url: url.to_string(),
        });
        self
    }

    pub fn security_scheme(mut self, name: &str, scheme: openapi::SecurityScheme) -> Self {
        self.security_schemes.insert(name.to_string(), scheme);
        self
    }

    pub fn bearer_auth(self) -> Self {
        self.security_scheme(
            "bearerAuth",
            openapi::SecurityScheme {
                scheme_type: "http".to_string(),
                scheme: Some("bearer".to_string()),
                bearer_format: None,
                name: None,
                location: None,
            },
        )
    }

    pub fn include(mut self, router: UltraApiRouter) -> Self {
        self.routers.push(router);
        self
    }

    /// Check if routers were explicitly included
    pub fn has_explicit_routes(&self) -> bool {
        !self.routers.is_empty()
    }

    /// Resolve all routes from included routers
    pub fn resolve_routes(&self) -> Vec<ResolvedRoute> {
        let mut resolved = Vec::new();
        for router in &self.routers {
            resolved.extend(router.resolve("", &[], &[]));
        }
        resolved
    }

    pub fn into_router(self) -> Router {
        let spec = self.generate_openapi_spec();
        let swagger_html = self.generate_swagger_html();
        let has_explicit = self.has_explicit_routes();
        let resolved = if has_explicit {
            self.resolve_routes()
        } else {
            Vec::new()
        };
        let spec_json =
            serde_json::to_string_pretty(&spec.to_json_with_query_params(&self.routers))
                .expect("Failed to serialize OpenAPI spec");

        // Merge deps from routers
        let mut all_deps = self.deps;
        for router in &self.routers {
            all_deps.extend(router.collect_deps());
        }

        let state = AppState {
            deps: Arc::new(all_deps),
        };

        let mut app = Router::new();

        if has_explicit {
            for r in &resolved {
                let axum_path = r.full_axum_path();
                let method_router = (r.route_info.method_router_fn)();
                app = app.route(&axum_path, method_router);
            }
        } else {
            for route in inventory::iter::<&RouteInfo> {
                app = (route.register_fn)(app);
            }
        }

        let spec_json_clone = spec_json.clone();
        app = app.route(
            "/openapi.json",
            axum::routing::get(move || {
                let spec = spec_json_clone.clone();
                async move { (StatusCode::OK, [("content-type", "application/json")], spec) }
            }),
        );

        app = app.route(
            "/docs",
            axum::routing::get(move || {
                let html = swagger_html.clone();
                async move { (StatusCode::OK, [("content-type", "text/html")], html) }
            }),
        );

        app.with_state(state)
    }

    pub async fn serve(self, addr: &str) {
        let app = self.into_router();

        let listener = tokio::net::TcpListener::bind(addr)
            .await
            .expect("Failed to bind to address");
        println!("ðŸš€ Hayai server running at http://{}", addr);
        println!("ðŸ“– Swagger UI available at http://{}/docs", addr);
        axum::serve(listener, app).await.expect("Server error");
    }

    fn build_operation(
        route: &RouteInfo,
        tags: Vec<String>,
        security_list: &[&str],
    ) -> openapi::Operation {
        let description = if route.description.is_empty() {
            None
        } else {
            Some(route.description.to_string())
        };

        let status_code = route.success_status.to_string();

        let security: Vec<HashMap<String, Vec<String>>> = security_list
            .iter()
            .map(|s| {
                let scheme_name = match *s {
                    "bearer" => "bearerAuth",
                    other => other,
                };
                let mut map = HashMap::new();
                map.insert(scheme_name.to_string(), vec![]);
                map
            })
            .collect();

        let schema_ref_value = if route.success_status == 204 {
            None
        } else if route.is_vec_response {
            Some(serde_json::json!({
                "type": "array",
                "items": { "$ref": format!("#/components/schemas/{}", route.vec_inner_type_name) }
            }))
        } else {
            Some(
                serde_json::json!({ "$ref": format!("#/components/schemas/{}", route.response_type_name) }),
            )
        };

        let success_desc = openapi::status_description(route.success_status).to_string();

        openapi::Operation {
            summary: Some(route.handler_name.replace('_', " ")),
            description,
            operation_id: Some(route.handler_name.to_string()),
            tags,
            parameters: route.parameters.to_vec(),
            request_body: if route.has_body {
                Some(openapi::RequestBody {
                    required: true,
                    content_type: "application/json".to_string(),
                    schema_ref: format!("#/components/schemas/{}", route.body_type_name),
                })
            } else {
                None
            },
            responses: {
                let mut map = HashMap::new();
                map.insert(
                    status_code,
                    openapi::ResponseDef {
                        description: success_desc,
                        schema_ref: schema_ref_value,
                    },
                );
                map.insert(
                    "400".to_string(),
                    openapi::ResponseDef {
                        description: "Bad Request".to_string(),
                        schema_ref: Some(
                            serde_json::json!({ "$ref": "#/components/schemas/ApiError" }),
                        ),
                    },
                );
                if route.is_result_return {
                    map.insert(
                        "404".to_string(),
                        openapi::ResponseDef {
                            description: "Not Found".to_string(),
                            schema_ref: Some(
                                serde_json::json!({ "$ref": "#/components/schemas/ApiError" }),
                            ),
                        },
                    );
                }
                if route.has_body {
                    map.insert(
                        "422".to_string(),
                        openapi::ResponseDef {
                            description: "Validation Failed".to_string(),
                            schema_ref: Some(
                                serde_json::json!({ "$ref": "#/components/schemas/ApiError" }),
                            ),
                        },
                    );
                }
                map.insert(
                    "500".to_string(),
                    openapi::ResponseDef {
                        description: "Internal Server Error".to_string(),
                        schema_ref: Some(
                            serde_json::json!({ "$ref": "#/components/schemas/ApiError" }),
                        ),
                    },
                );
                map
            },
            security,
        }
    }

    fn generate_swagger_html(&self) -> String {
        match &self.swagger_mode {
            SwaggerMode::Cdn(cdn_base) => {
                format!(
                    r#"<!DOCTYPE html>
<html>
<head>
    <title>{title} - Swagger UI</title>
    <link rel="stylesheet" type="text/css" href="{cdn}/swagger-ui.css" >
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="{cdn}/swagger-ui-bundle.js"> </script>
    <script>
    SwaggerUIBundle({{
        url: "/openapi.json",
        dom_id: '#swagger-ui',
        presets: [SwaggerUIBundle.presets.apis, SwaggerUIBundle.SwaggerUIStandalonePreset],
        layout: "BaseLayout"
    }})
    </script>
</body>
</html>"#,
                    title = self.title,
                    cdn = cdn_base,
                )
            }
            SwaggerMode::Embedded => {
                format!(
                    r#"<!DOCTYPE html>
<html>
<head>
    <title>{title} - API Reference</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>{css}</style>
</head>
<body>
    <script id="api-reference" data-url="/openapi.json"></script>
    <script>{js}</script>
</body>
</html>"#,
                    title = self.title,
                    css = include_str!("../assets/scalar.min.css"),
                    js = include_str!("../assets/scalar.min.js"),
                )
            }
        }
    }

    fn generate_openapi_spec(&self) -> openapi::OpenApiSpec {
        let mut schemas = HashMap::new();

        // Add ApiError schema
        schemas.insert("ApiError".to_string(), openapi::api_error_schema());

        for info in inventory::iter::<SchemaInfo> {
            schemas.insert(info.name.to_string(), (info.schema_fn)());
            for (nested_name, nested_schema) in (info.nested_fn)() {
                schemas.entry(nested_name).or_insert(nested_schema);
            }
        }

        let mut paths = HashMap::new();

        if self.has_explicit_routes() {
            let resolved = self.resolve_routes();
            for r in &resolved {
                let route = r.route_info;
                let full_path = r.full_path();
                let tags = r.merged_tags();
                let sec = r.merged_security();
                let operation = Self::build_operation(route, tags, &sec);
                let path_item = paths.entry(full_path).or_insert_with(HashMap::new);
                path_item.insert(route.method.to_lowercase(), operation);
            }
        } else {
            for route in inventory::iter::<&RouteInfo> {
                let tags: Vec<String> = route.tags.iter().map(|s| s.to_string()).collect();
                let sec: Vec<&str> = route.security.to_vec();
                let operation = Self::build_operation(route, tags, &sec);
                let path_item = paths
                    .entry(route.path.to_string())
                    .or_insert_with(HashMap::new);
                path_item.insert(route.method.to_lowercase(), operation);
            }
        }

        openapi::OpenApiSpec {
            openapi: "3.1.0".to_string(),
            info: openapi::Info {
                title: self.title.clone(),
                version: self.version.clone(),
                description: self.description.clone(),
                contact: self.contact.clone(),
                license: self.license.clone(),
            },
            servers: self.servers.clone(),
            paths,
            schemas,
            security_schemes: self.security_schemes.clone(),
        }
    }
}

impl openapi::OpenApiSpec {
    /// Enhanced to_json that includes dynamic query parameters
    pub fn to_json_with_query_params(&self, routers: &[UltraApiRouter]) -> serde_json::Value {
        let mut val = self.to_json();

        // Build path mapping: for each route, determine the actual spec path
        let use_routers = !routers.is_empty();

        struct RoutePathInfo {
            spec_path: String,
            method: String,
            query_params_fn: Option<fn() -> Vec<openapi::DynParameter>>,
        }

        let mut route_paths = Vec::new();

        if use_routers {
            for router in routers {
                let resolved = router.resolve("", &[], &[]);
                for r in &resolved {
                    if let Some(qfn) = r.route_info.query_params_fn {
                        route_paths.push(RoutePathInfo {
                            spec_path: r.full_path(),
                            method: r.route_info.method.to_lowercase(),
                            query_params_fn: Some(qfn),
                        });
                    }
                }
            }
        } else {
            for route in inventory::iter::<&RouteInfo> {
                if let Some(qfn) = route.query_params_fn {
                    route_paths.push(RoutePathInfo {
                        spec_path: route.path.to_string(),
                        method: route.method.to_lowercase(),
                        query_params_fn: Some(qfn),
                    });
                }
            }
        }

        for rp in &route_paths {
            if let Some(qfn) = rp.query_params_fn {
                let dyn_params = qfn();
                if !dyn_params.is_empty() {
                    let escaped = rp.spec_path.replace('~', "~0").replace('/', "~1");
                    let pointer = format!("/paths/{}/{}", escaped, rp.method);
                    if let Some(op) = val.pointer_mut(&pointer) {
                        let params = op
                            .get("parameters")
                            .and_then(|v| v.as_array())
                            .cloned()
                            .unwrap_or_default();
                        let mut all_params = params;
                        for dp in &dyn_params {
                            let mut schema = serde_json::json!({ "type": dp.schema_type });
                            if let Some(v) = dp.minimum {
                                schema["minimum"] = serde_json::json!(v);
                            }
                            if let Some(v) = dp.maximum {
                                schema["maximum"] = serde_json::json!(v);
                            }
                            if let Some(v) = dp.min_length {
                                schema["minLength"] = serde_json::json!(v);
                            }
                            if let Some(v) = dp.max_length {
                                schema["maxLength"] = serde_json::json!(v);
                            }
                            if let Some(v) = &dp.pattern {
                                schema["pattern"] = serde_json::json!(v);
                            }
                            let mut param = serde_json::json!({
                                "name": dp.name,
                                "in": dp.location,
                                "required": dp.required,
                                "schema": schema
                            });
                            if let Some(desc) = &dp.description {
                                param["description"] = serde_json::Value::String(desc.clone());
                            }
                            all_params.push(param);
                        }
                        op["parameters"] = serde_json::Value::Array(all_params);
                    }
                }
            }
        }

        val
    }
}

// Backward compatibility aliases (deprecated, use UltraApiApp and UltraApiRouter)
#[allow(deprecated)]
pub use UltraApiApp as HayaiApp;
#[allow(deprecated)]
pub use UltraApiRouter as HayaiRouter;
