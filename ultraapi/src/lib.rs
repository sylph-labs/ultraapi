pub mod grpc;
pub mod lifespan;
pub mod middleware;
pub mod openapi;
pub mod response_tasks;
pub mod streaming;
pub mod templates;
pub mod test_client;

use axum::http::{Method, StatusCode};
use axum::response::{IntoResponse, Response};
use axum::Router;
use std::pin::Pin;

use futures_util::stream::{StreamExt, TryStreamExt};
use serde::Serialize;
use std::any::{Any, TypeId};
use std::collections::HashMap;
use std::path::Path;
use std::sync::Arc;

use lifespan::Lifecycle;
use middleware::MiddlewareBuilder;

// Re-exports
pub use axum;
pub use axum_extra;
pub use inventory;
pub use regex;
pub use schemars;
pub use serde;
pub use serde_json;
pub use tokio_stream;

/// OAuth2 モジュール
/// 
/// OAuth2 の実運用で必要となる型とヘルパを提供します。
/// 
/// # 含まれるもの
/// 
/// - `OAuth2PasswordRequestForm` - パスワードフローのリクエストフォーム
/// - `TokenResponse` - トークンレスポンス
/// - `OAuth2ErrorResponse` - エラーレスポンス
/// - `TokenData` - トークンデータ
/// - `AuthError` - 認証エラー
/// - `OAuth2TokenValidator` - トークンバリデーター trait
/// - `OpaqueTokenValidator` - 不透明トークンバリデーターの実装例
/// 
/// # Example
/// 
/// ```ignore
/// use ultraapi::oauth2::{OAuth2PasswordRequestForm, TokenResponse};
/// ```
pub mod oauth2 {
    pub use crate::middleware::{
        OAuth2PasswordRequestForm,
        TokenResponse,
        OAuth2ErrorResponse,
        TokenData,
        OAuth2AuthError,
        OAuth2TokenValidator,
        OpaqueTokenValidator,
        create_bearer_auth_error,
    };
}

pub mod prelude {
    pub use crate::axum;
    pub use crate::inventory;
    pub use crate::schemars;
    pub use crate::serde;
    pub use crate::response_tasks::{BackgroundTasks, response_task_middleware};
    pub use crate::templates::{TemplateResponse, Templates, template_response};
    pub use crate::{
        lifespan::Lifecycle,
        middleware::{
            CompressionConfig, 
            CorsConfig, 
            MiddlewareBuilder,
            OAuth2PasswordBearer,
            OAuth2AuthorizationCodeBearer,
            OptionalOAuth2PasswordBearer,
            OptionalOAuth2AuthorizationCodeBearer,
            OAuth2Scopes,
            // OAuth2 Production Components
            OAuth2PasswordRequestForm,
            TokenResponse,
            OAuth2ErrorResponse,
            TokenData,
            OAuth2AuthError,
            OAuth2TokenValidator,
            OpaqueTokenValidator,
            create_bearer_auth_error,
        },
    };
    pub use crate::{sse_data, sse_event};
    pub use crate::streaming::{
        reader_stream,
        reader_stream_infallible,
        bytes_stream,
        iter_stream,
        string_stream,
        lines_stream,
        map_to_bytes,
    };
    pub use crate::{
        ApiError,
        CookieOptions,
        CookieResponse,
        Depends,
        Dep,
        FileResponse,
        Generator,
        RedirectResponse,
        ResponseClass,
        ResponseModelOptions,
        Scope,
        State,
        StreamingResponse,
        UltraApiApp,
        UltraApiRouter,
        Validate,
        YieldDep,
        DependencyScope,
        test_client::TestClient,
    };
    pub use axum::extract::{Form, Multipart, Path, Query};
    pub use axum_extra::extract::{CookieJar, TypedHeader};
    pub use ultraapi_macros::{api_model, delete, get, head, options, patch, post, put, sse, trace, ws};
}

/// Global error handler type - converts any exception into an HTTP response
/// 
/// The handler receives:
/// - AppState for accessing dependencies  
/// - The HTTP request (for context like path, method, headers)
/// - The error/exception that was thrown (as Box<dyn Any>)
/// 
/// Returns any type that implements `IntoResponse`
pub type CustomErrorHandler = Arc<
    dyn Fn(
            AppState,
            axum::http::Request<axum::body::Body>,
            Box<dyn std::any::Any + Send + 'static>,
        ) -> BoxFuture<'static, Response>
        + Send
        + Sync,
>;

/// Alias for the boxed future type
pub type BoxFuture<'a, T> = std::pin::Pin<Box<dyn std::future::Future<Output = T> + Send + 'a>>;

/// SSE helper macros
#[macro_export]
macro_rules! sse_data {
    ($data:expr) => {
        axum::sse::Event::default().data($data)
    };
    ($($arg:tt)*) => {
        axum::sse::Event::default().data(format!($($arg)*))
    };
}

/// Create an SSE event with custom event type
#[macro_export]
macro_rules! sse_event {
    ($event_type:expr, $data:expr) => {
        axum::sse::Event::default()
            .event($event_type)
            .data($data)
    };
    ($event_type:expr, $($arg:tt)*) => {
        axum::sse::Event::default()
            .event($event_type)
            .data(format!($($arg)*))
    };
}

/// Validation trait generated by api_model attribute
pub trait Validate {
    fn validate(&self) -> Result<(), Vec<String>>;
}

/// Marker trait to indicate a type has custom validation logic via Validate.
/// This is automatically implemented for types marked with #[api_model].
pub trait HasValidate: Validate {}

/// Query/Form/Bodyパラメータのvalidationを行うラッパータイプ
/// 
/// # 概要
/// 
/// UltraAPIは、Query<T>パラメータ自動的にvalidate()を呼び出す機能を提供します。
/// - `#[api_model]`でマークされた型（api_model型）は、validationが自動的に実行されます
/// - api_modelでない型はvalidationをスキップします（no-op）
/// 
/// # 動作原理
/// 
/// 内部的にはinventory registryを使用してruntime時に型を判定します：
/// 1. `#[api_model]`マクロは、validator情報をinventoryに登録します
/// 2. ルート処理時に`ValidatedWrapper`を使用してvalidationを実行します
/// 3. 登録されたvalidatorがある場合のみvalidationを呼び出します
/// 
/// # 使用方法
/// 
/// ```ignore
/// #[api_model]
/// struct MyQuery {
///     #[validate(minimum = 1)]
///     limit: i64,
/// }
/// 
/// #[get("/items")]
/// async fn list_items(query: Query<MyQuery>) -> Vec<Item> {
///     // queryは自動的にvalidationされます
///     // validation失敗時は422エラーを返します
/// }
/// ```
/// 
/// # Error Response
/// 
/// validation失敗時のレスポンス形式はBody/Formと統一されています：
/// ```json
/// {
///     "error": "Validation failed",
///     "details": ["limit must be at least 1"]
/// }
/// ```
/// 
/// # OpenAPIとの統合
/// 
/// QueryパラメータのOpenAPI schemaは自動的に生成されます：
/// - requiredフィールド→OpenAPIのrequired配列に追加
/// - nullable設定→OpenAPI schemaに反映
/// - validate属性→OpenAPI schemaの制約として反映
/// 
/// Registry entry for types that have Validate implementation (api_model types)
/// Used by ValidatedWrapper to determine if a type should be validated at runtime.
#[derive(Clone, Copy)]
pub struct ValidatorInfo {
    /// Type name for matching at runtime
    pub type_name: &'static str,
    /// Validation function - takes &dyn Any and returns Result
    pub validate_fn: fn(&dyn std::any::Any) -> Result<(), Vec<String>>,
}

inventory::collect!(ValidatorInfo);

/// Wrapper type for validated query/body/form parameters.
/// 
/// This wrapper checks the inventory registry at runtime to determine if the inner type
/// has validation logic (api_model types). If so, it calls validate(). Otherwise, it's a no-op.
///
/// This approach avoids trait implementation conflicts by using runtime type checking.
pub struct ValidatedWrapper<T: ?Sized>(pub T);

/// Validates the wrapped value if it's an api_model type (registered in inventory).
impl<T: 'static> ValidatedWrapper<T> {
    /// Validate the wrapped value if it has a registered validator.
    /// Returns Ok(()) if no validator is registered (non-api_model types).
    pub fn validate(value: &T) -> Result<(), Vec<String>> {
        // Get the simple type name (last segment of the full path)
        let full_type_name = std::any::type_name::<T>();
        let simple_name = full_type_name.rsplit("::").next().unwrap_or(full_type_name);
        
        // Iterate through registered validators to find a match
        for validator in inventory::iter::<ValidatorInfo> {
            if validator.type_name == simple_name {
                // Found matching validator - call it
                let any_ref: &dyn std::any::Any = value;
                return (validator.validate_fn)(any_ref);
            }
        }
        
        // No validator found - no-op
        Ok(())
    }
}

impl Validate for () {
    fn validate(&self) -> Result<(), Vec<String>> {
        Ok(())
    }
}

#[async_trait::async_trait]
pub trait AsyncValidate: Send + Sync {
    async fn validate_async(&self, _state: &AppState) -> Result<(), Vec<String>> {
        Ok(())
    }
}

#[async_trait::async_trait]
impl AsyncValidate for () {
    async fn validate_async(&self, _state: &AppState) -> Result<(), Vec<String>> {
        Ok(())
    }
}

#[macro_export]
macro_rules! impl_async_validate {
    ($ty:ty, $sync_fn:ident) => {
        #[async_trait::async_trait]
        impl $crate::AsyncValidate for $ty {
            async fn validate_async(&self, _state: &$crate::AppState) -> Result<(), Vec<String>> {
                $sync_fn(self)
            }
        }
    };
}

/// Trait for schema patches from validation attributes
#[doc(hidden)]
pub trait HasSchemaPatches {
    fn patch_schema(props: &mut HashMap<String, openapi::PropertyPatch>);
}

/// Application state holding dependency injection container
#[derive(Clone)]
pub struct AppState {
    deps: Arc<HashMap<TypeId, Arc<dyn Any + Send + Sync>>>,
    /// Optional resolver for Depends function-based dependencies
    depends_resolver: Option<Arc<DependsResolver>>,
}

impl Default for AppState {
    fn default() -> Self {
        Self::new()
    }
}

impl AppState {
    pub fn new() -> Self {
        Self {
            deps: Arc::new(HashMap::new()),
            depends_resolver: None,
        }
    }

    /// Get a registered dependency
    pub fn get<T: 'static + Send + Sync>(&self) -> Option<Arc<T>> {
        self.deps
            .get(&TypeId::of::<T>())
            .and_then(|v| v.clone().downcast::<T>().ok())
    }

    /// Get the Depends resolver if available
    pub fn get_depends_resolver(&self) -> Option<&Arc<DependsResolver>> {
        self.depends_resolver.as_ref()
    }

    /// Set the Depends resolver
    pub fn set_depends_resolver(&mut self, resolver: Arc<DependsResolver>) {
        self.depends_resolver = Some(resolver);
    }
}

/// Dependency injection extractor
pub struct Dep<T: 'static + Send + Sync>(Arc<T>);

impl<T: 'static + Send + Sync> Dep<T> {
    pub fn from_app_state(state: &AppState) -> Result<Self, ApiError> {
        state.get::<T>().map(Dep).ok_or_else(|| {
            ApiError::internal(format!(
                "Dependency not registered: {}",
                std::any::type_name::<T>()
            ))
        })
    }
}

impl<T: 'static + Send + Sync> std::ops::Deref for Dep<T> {
    type Target = T;
    fn deref(&self) -> &T {
        &self.0
    }
}

/// Axum-style state extractor — alternative to Dep<T>
/// Both work identically; choose based on your preferred style.
pub struct State<T: 'static + Send + Sync>(Arc<T>);

impl<T: 'static + Send + Sync> State<T> {
    pub fn from_app_state(state: &AppState) -> Result<Self, ApiError> {
        state.get::<T>().map(State).ok_or_else(|| {
            ApiError::internal(format!(
                "State not registered: {}",
                std::any::type_name::<T>()
            ))
        })
    }
}

impl<T: 'static + Send + Sync> std::ops::Deref for State<T> {
    type Target = T;
    fn deref(&self) -> &T {
        &self.0
    }
}

// =============================================================================
// FastAPI-compatible Depends function-based dependency injection
// =============================================================================

/// Scope for yield-based dependencies (FastAPI-style)
///
/// - `Function`: cleanup runs before response is returned
/// - `Request`: cleanup runs after response handling completes
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum Scope {
    /// Cleanup runs before the handler returns its response
    #[default]
    Function,
    /// Cleanup runs after the entire request handling completes
    Request,
}

/// Trait for yield-based generators with cleanup hooks (FastAPI-style).
///
/// Implementors yield a value, then run cleanup when the scope ends.
/// This is similar to FastAPI's `yield` dependencies.
///
/// # Example
///
/// ```ignore
/// struct DatabaseConnection { ... }
///
/// impl Generator for DatabaseConnection {
///     type Output = Self;
///     type Error = DependencyError;
///
///     fn generate(
///         self: Arc<Self>,
///         scope: Scope,
///     ) -> impl Future<Output = Result<Self::Output, Self::Error>> + Send {
///         async move {
///             // Setup: connect to database
///             Ok(DatabaseConnection { ... })
///         }
///     }
///
///     fn cleanup(self: Arc<Self>) -> impl Future<Output = Result<(), DependencyError>> + Send {
///         async move {
///             // Cleanup: close connection
///             Ok(())
///         }
///     }
/// }
/// ```
/// 
/// For type-erased usage in DependsResolver (internal)
/// Uses boxed futures to be dyn-compatible
#[async_trait::async_trait]
pub trait DynGenerator: Send + Sync + 'static {
    /// Generate the dependency value
    fn generate(
        self: Arc<Self>,
        scope: Scope,
    ) -> std::pin::Pin<Box<dyn Future<Output = Result<Arc<dyn std::any::Any + Send + Sync>, DependencyError>> + Send>>;

    /// Cleanup hook called when the scope ends
    fn cleanup(self: Arc<Self>) -> std::pin::Pin<Box<dyn Future<Output = Result<(), DependencyError>> + Send>>;
}

/// Blanket implementation for any Generator<T>
#[async_trait::async_trait]
impl<T, G> DynGenerator for G
where
    T: Send + Sync + 'static,
    G: Generator<Output = T, Error = DependencyError> + Send + Sync + 'static,
{
    fn generate(
        self: Arc<Self>,
        scope: Scope,
    ) -> std::pin::Pin<Box<dyn Future<Output = Result<Arc<dyn std::any::Any + Send + Sync>, DependencyError>> + Send>> {
        let result = Generator::generate(self.clone(), scope);
        Box::pin(async move {
            let output = result.await?;
            // Wrap in a new Arc of type-erased Any
            Ok(Arc::new(Erased(output)) as Arc<dyn std::any::Any + Send + Sync>)
        })
    }

    fn cleanup(self: Arc<Self>) -> std::pin::Pin<Box<dyn Future<Output = Result<(), DependencyError>> + Send>> {
        let result = Generator::cleanup(self.clone());
        Box::pin(result)
    }
}

/// Internal type for wrapping generator outputs
struct Erased<T: ?Sized>(T);

/// Marker trait for yield-based generators (FastAPI-style).
///
/// Implementors yield a value, then run cleanup when the scope ends.
/// 
/// # Example
///
/// ```ignore
/// use ultraapi::prelude::*;
/// use std::sync::Arc;
///
/// struct DatabasePool {
///     connection_string: String,
/// }
///
/// #[async_trait::async_trait]
/// impl Generator for DatabasePool {
///     type Output = Self;
///     type Error = DependencyError;
///
///     async fn generate(self: Arc<Self>, _scope: Scope) -> Result<Self::Output, Self::Error> {
///         Ok(Arc::try_unwrap(self).unwrap_or_else(|a| (*a).clone()))
///     }
///
///     async fn cleanup(self: Arc<Self>) -> Result<(), Self::Error> {
///         println!("Cleaning up database pool");
///         Ok(())
///     }
/// }
/// ```
#[async_trait::async_trait]
pub trait Generator: Send + Sync + 'static {
    /// The type yielded by the generator
    type Output: Send + Sync;
    /// Error type if generation or cleanup fails
    type Error: std::fmt::Display + Send + Sync;

    /// Generate the dependency value
    async fn generate(
        self: Arc<Self>,
        scope: Scope,
    ) -> Result<Self::Output, Self::Error>;

    /// Cleanup hook called when the scope ends
    async fn cleanup(self: Arc<Self>) -> Result<(), Self::Error>;
}

/// Wrapper for yield-based dependencies with automatic cleanup
pub struct YieldDep<G: Generator> {
    generator: Arc<G>,
    value: Option<Arc<G::Output>>,
    scope: Scope,
}

impl<G: Generator> YieldDep<G> {
    /// Create a new yield dependency
    pub fn new(generator: Arc<G>, scope: Scope) -> Self {
        Self {
            generator,
            value: None,
            scope,
        }
    }

    /// Resolve the dependency (call generate)
    pub async fn resolve(&mut self) -> Result<Arc<G::Output>, DependencyError> {
        let value = self.generator.clone().generate(self.scope).await
            .map_err(|e| DependencyError {
                dependency: std::any::type_name::<G>().to_string(),
                message: e.to_string(),
                chain: vec![],
            })?;
        
        let arc_value = Arc::new(value);
        self.value = Some(arc_value.clone());
        Ok(arc_value)
    }

    /// Get the resolved value
    pub fn get(&self) -> Option<&Arc<G::Output>> {
        self.value.as_ref()
    }

    /// Run cleanup (call the generator's cleanup)
    pub async fn cleanup(&mut self) -> Result<(), DependencyError> {
        if let Some(_value) = self.value.take() {
            // We need to reconstruct the generator with the value for cleanup
            // For simplicity, we'll use the generator directly
            self.generator.clone().cleanup().await
                .map_err(|e| DependencyError {
                    dependency: std::any::type_name::<G>().to_string(),
                    message: format!("Cleanup failed: {}", e),
                    chain: vec![],
                })?;
        }
        Ok(())
    }

    /// Get the scope
    pub fn scope(&self) -> Scope {
        self.scope
    }
}

/// Request-level state for tracking yield dependency cleanup hooks
#[derive(Clone, Default)]
pub struct DependencyScope {
    /// Function-scoped cleanup hooks (run before response)
    function_hooks: Arc<parking_lot::Mutex<Vec<Box<dyn FnOnce() + Send + Sync>>>>,
    /// Request-scoped cleanup hooks (run after response)
    request_hooks: Arc<parking_lot::Mutex<Vec<Box<dyn FnOnce() + Send + Sync>>>>,
}

impl DependencyScope {
    /// Create a new dependency scope
    pub fn new() -> Self {
        Self::default()
    }

    /// Register a cleanup hook for function scope
    pub fn add_function_hook<F>(&self, hook: F)
    where
        F: FnOnce() + Send + Sync + 'static,
    {
        self.function_hooks.lock().push(Box::new(hook));
    }

    /// Register a cleanup hook for request scope
    pub fn add_request_hook<F>(&self, hook: F)
    where
        F: FnOnce() + Send + Sync + 'static,
    {
        self.request_hooks.lock().push(Box::new(hook));
    }

    /// Run all function-scope cleanup hooks
    /// Returns the first error encountered, if any
    pub async fn run_function_cleanup(&self) {
        let mut hooks = self.function_hooks.lock();
        for hook in hooks.drain(..) {
            hook();
        }
    }

    /// Run all request-scope cleanup hooks
    /// Returns the first error encountered, if any
    pub async fn run_request_cleanup(&self) {
        let mut hooks = self.request_hooks.lock();
        for hook in hooks.drain(..) {
            hook();
        }
    }
}

/// Error type for dependency injection failures
#[derive(Debug, Clone, Serialize)]
pub struct DependencyError {
    pub dependency: String,
    pub message: String,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub chain: Vec<String>,
}

impl DependencyError {
    pub fn missing(dependency: &str) -> Self {
        Self {
            dependency: dependency.to_string(),
            message: format!("Dependency not found: {}", dependency),
            chain: vec![],
        }
    }

    pub fn cycle(dependency: &str, chain: Vec<String>) -> Self {
        Self {
            dependency: dependency.to_string(),
            message: format!("Circular dependency detected: {}", dependency),
            chain,
        }
    }

    pub fn missing_with_chain(dependency: &str, chain: Vec<String>) -> Self {
        Self {
            dependency: dependency.to_string(),
            message: format!("Dependency not found in chain: {}", dependency),
            chain,
        }
    }
}

impl std::fmt::Display for DependencyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)?;
        if !self.chain.is_empty() {
            write!(f, " (chain: {})", self.chain.join(" -> "))?;
        }
        Ok(())
    }
}

impl std::error::Error for DependencyError {}

/// Marker struct for Depends - represents a resolved dependency value
pub struct Depends<T: Send + Sync>(pub Arc<T>);

impl<T: 'static + Send + Sync> Depends<T> {
    pub fn from_app_state(_state: &AppState) -> Result<Self, ApiError> {
        // This is the fallback - actual resolution happens via DependsResolver
        // The macro-generated code uses DependsResolver for proper nested resolution
        Err(ApiError::internal(
            "Depends resolver not properly initialized".to_string(),
        ))
    }
}

impl<T: 'static + Send + Sync> std::ops::Deref for Depends<T> {
    type Target = T;
    fn deref(&self) -> &T {
        &self.0
    }
}

/// Internal: Wrapper for dependency functions that stores metadata
struct DependsFunc {
    name: &'static str,
    // Store the function using type erasure with Arc
    func: Arc<dyn Fn(AppState) -> std::pin::Pin<Box<dyn Future<Output = Result<Box<dyn std::any::Any + Send + Sync>, DependencyError>> + Send>> + Send + Sync>,
    #[allow(dead_code)]
    output_type_name: &'static str,
}

/// Thread-safe resolver for Depends dependencies with cycle detection
pub struct DependsResolver {
    // Map from TypeId to the registered dependency function
    deps: parking_lot::RwLock<HashMap<TypeId, DependsFunc>>,
    // Map from TypeId to registered generator (yield-based dependencies)
    generators: parking_lot::RwLock<HashMap<TypeId, GeneratorRegistryEntry>>,
    // Map from TypeId to dependency chain info (what deps this dependency needs)
    dep_chains: parking_lot::RwLock<HashMap<TypeId, Vec<TypeId>>>,
}

/// Entry for a registered generator
#[derive(Clone)]
struct GeneratorRegistryEntry {
    name: &'static str,
    generator: Arc<dyn DynGenerator + Send + Sync>,
    scope: Scope,
}

impl Default for DependsResolver {
    fn default() -> Self {
        Self::new()
    }
}

impl DependsResolver {
    pub fn new() -> Self {
        Self {
            deps: parking_lot::RwLock::new(HashMap::new()),
            generators: parking_lot::RwLock::new(HashMap::new()),
            dep_chains: parking_lot::RwLock::new(HashMap::new()),
        }
    }

    /// Register a yield-based dependency (generator with cleanup)
    /// 
    /// The generator will be called to produce the dependency value,
    /// and its cleanup will be called based on the specified scope.
    pub fn register_yield<T, G>(&self, _marker: std::marker::PhantomData<T>, generator: G, scope: Scope)
    where
        T: Send + Sync + 'static,
        G: Generator<Output = T, Error = DependencyError> + Send + Sync + 'static,
    {
        let name = std::any::type_name::<T>();
        
        // Wrap the generator using the blanket impl of DynGenerator
        let wrapped: Arc<dyn DynGenerator + Send + Sync> = Arc::new(generator);
        
        let mut generators = self.generators.write();
        generators.insert(
            TypeId::of::<T>(),
            GeneratorRegistryEntry {
                name,
                generator: wrapped,
                scope,
            },
        );
    }

    /// Check if a type is registered as a generator
    pub fn is_generator<T: 'static>(&self) -> bool {
        self.generators.read().contains_key(&TypeId::of::<T>())
    }

    /// Get the scope for a registered generator
    pub fn get_generator_scope<T: 'static>(&self) -> Option<Scope> {
        self.generators.read()
            .get(&TypeId::of::<T>())
            .map(|entry| entry.scope)
    }

    /// Resolve a generator dependency and register cleanup hooks
    pub async fn resolve_generator<T: 'static + Send + Sync>(
        &self,
        _state: &AppState,
        dependency_scope: &DependencyScope,
    ) -> Result<Arc<dyn std::any::Any + Send + Sync>, DependencyError> {
        let entry = self.generators.read()
            .get(&TypeId::of::<T>())
            .cloned()
            .ok_or_else(|| DependencyError::missing(std::any::type_name::<T>()))?;
        
        let generator = entry.generator.clone();
        let scope = entry.scope;

        // Generate the value
        let value = generator.clone().generate(scope).await
            .map_err(|e| DependencyError {
                dependency: entry.name.to_string(),
                message: e.to_string(),
                chain: vec![],
            })?;

        // Register cleanup based on scope
        let generator_for_cleanup = generator.clone();
        match scope {
            Scope::Function => {
                dependency_scope.add_function_hook(move || {
                    // Run cleanup synchronously for function scope (can't use async here)
                    // In practice, we'd need a runtime to run async cleanup
                    // For simplicity, we'll note that async cleanup should use spawn
                    let gen = generator_for_cleanup.clone();
                    tokio::spawn(async move {
                        let _ = gen.cleanup().await;
                    });
                });
            }
            Scope::Request => {
                dependency_scope.add_request_hook(move || {
                    let gen = generator_for_cleanup.clone();
                    tokio::spawn(async move {
                        let _ = gen.cleanup().await;
                    });
                });
            }
        }

        Ok(value)
    }

    /// Register a dependency function
    pub fn register<T, F, R>(&self, _marker: std::marker::PhantomData<T>, func: F)
    where
        T: Send + Sync + 'static,
        F: Fn(AppState) -> R + Send + Sync + 'static,
        R: Future<Output = Result<T, DependencyError>> + Send + 'static,
    {
        let name = std::any::type_name::<T>();
        let output_type_name = name;

        let func_arc: Arc<dyn Fn(AppState) -> std::pin::Pin<Box<dyn Future<Output = Result<Box<dyn std::any::Any + Send + Sync>, DependencyError>> + Send>> + Send + Sync> = Arc::new(move |state: AppState| {
            let future = func(state);
            Box::pin(async move {
                match future.await {
                    Ok(val) => Ok(Box::new(val) as Box<dyn std::any::Any + Send + Sync>),
                    Err(e) => Err(e),
                }
            })
        });

        let mut deps = self.deps.write();
        deps.insert(
            TypeId::of::<T>(),
            DependsFunc {
                name,
                func: func_arc,
                output_type_name,
            },
        );
    }

    /// Resolve a dependency with cycle detection
    pub async fn resolve<T: 'static + Send + Sync>(
        &self,
        state: &AppState,
    ) -> Result<Arc<T>, DependencyError> {
        // Track resolution chain for cycle detection
        let mut visiting: std::collections::HashSet<TypeId> = std::collections::HashSet::new();
        self.resolve_recursive::<T>(state, &mut visiting).await
    }

    async fn resolve_recursive<T: 'static + Send + Sync>(
        &self,
        state: &AppState,
        visiting: &mut std::collections::HashSet<TypeId>,
    ) -> Result<Arc<T>, DependencyError> {
        let type_id = TypeId::of::<T>();

        // Cycle detection: if we're already visiting this type in the current chain
        if visiting.contains(&type_id) {
            let chain: Vec<String> = visiting
                .iter()
                .map(|tid| {
                    // Find the dependency name (best effort)
                    let deps = self.deps.read();
                    for (registered_tid, func) in deps.iter() {
                        if registered_tid == tid {
                            return func.name.to_string();
                        }
                    }
                    format!("{:?}", tid)
                })
                .chain(std::iter::once(std::any::type_name::<T>().to_string()))
                .collect();

            return Err(DependencyError::cycle(std::any::type_name::<T>(), chain));
        }

        // Mark as visiting
        visiting.insert(type_id);

        // First, check if there are any nested dependencies registered via register_with_deps
        // and resolve them first. This enables dependency chaining.
        {
            let chains = self.dep_chains.read();
            if let Some(deps) = chains.get(&type_id) {
                // We have registered deps - in a full implementation, we'd resolve them here
                // For now, we store the dependency chain info and let the function access
                // pre-resolved deps from AppState
                let _deps = deps.clone(); // Placeholder for nested resolution
            }
        }

        // First, try to get from AppState (backward compatibility with Dep<T>/State<T>)
        if let Some(dep) = state.get::<T>() {
            visiting.remove(&type_id);
            return Ok(dep);
        }

        // Try to resolve via registered Depends function
        let deps = self.deps.read();
        if let Some(func) = deps.get(&type_id) {
            let func = Arc::clone(&func.func);
            drop(deps); // Release lock before async call

            // Call the function to resolve the dependency
            let boxed_result = (func)(state.clone()).await;

            // Check for cycles after resolution
            visiting.remove(&type_id);

            // Convert Box<dyn Any + Send + Sync> to Arc<T>
            match boxed_result {
                Ok(boxed) => {
                    match boxed.downcast::<T>() {
                        Ok(t) => Ok(Arc::new(*t)),
                        Err(_) => Err(DependencyError::missing(std::any::type_name::<T>())),
                    }
                }
                Err(e) => Err(e),
            }
        } else {
            visiting.remove(&type_id);
            Err(DependencyError::missing(std::any::type_name::<T>()))
        }
    }

    /// Register a dependency function along with its dependency chain info.
    /// 
    /// This enables automatic resolution of nested dependencies. When resolving,
    /// the resolver will first resolve any dependencies listed in `depends_on`.
    /// 
    /// # Example
    /// 
    /// ```ignore
    /// use ultraapi::prelude::*;
    /// use std::sync::Arc;
    /// 
    /// #[derive(Clone)]
    /// struct DbPool { connection_string: String }
    /// 
    /// #[derive(Clone)]
    /// struct UserRepository { pool: Arc<DbPool> }
    /// 
    /// // A dependency that needs another dependency
    /// async fn get_user_repo(state: AppState) -> Result<Arc<UserRepository>, DependencyError> {
    ///     let pool = state.get::<DbPool>().ok_or_else(|| DependencyError::missing("DbPool"))?;
    ///     Ok(Arc::new(UserRepository { pool }))
    /// }
    /// 
    /// // Register with dependency chain info
    /// resolver.register_with_deps(
    ///     std::marker::PhantomData::<UserRepository>,
    ///     get_user_repo,
    ///     vec![TypeId::of::<DbPool>()],  // UserRepository depends on DbPool
    /// );
    /// ```
    pub fn register_with_deps<T, F, R>(&self, _marker: std::marker::PhantomData<T>, func: F, depends_on: Vec<TypeId>)
    where
        T: Send + Sync + 'static,
        F: Fn(AppState) -> R + Send + Sync + 'static,
        R: Future<Output = Result<T, DependencyError>> + Send + 'static,
    {
        // First register the function
        self.register(std::marker::PhantomData::<T>, func);
        
        // Then register the dependency chain info
        let mut chains = self.dep_chains.write();
        chains.insert(TypeId::of::<T>(), depends_on);
    }

    /// Check if a type has registered dependencies
    pub fn has_deps<T: 'static>(&self) -> bool {
        self.dep_chains.read().contains_key(&TypeId::of::<T>())
    }

    /// Get the registered dependencies for a type
    pub fn get_deps<T: 'static>(&self) -> Option<Vec<TypeId>> {
        self.dep_chains.read().get(&TypeId::of::<T>()).cloned()
    }
}

// Re-export for convenience
pub use std::future::Future;

/// API Error type
#[derive(Debug, Serialize)]
pub struct ApiError {
    #[serde(skip)]
    pub status: StatusCode,
    pub error: String,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub details: Vec<String>,
}

impl ApiError {
    pub fn unauthorized(msg: impl Into<String>) -> Self {
        Self {
            status: StatusCode::UNAUTHORIZED,
            error: msg.into(),
            details: vec![],
        }
    }

    pub fn bad_request(msg: String) -> Self {
        Self {
            status: StatusCode::BAD_REQUEST,
            error: msg,
            details: vec![],
        }
    }

    pub fn forbidden(msg: impl Into<String>) -> Self {
        Self {
            status: StatusCode::FORBIDDEN,
            error: msg.into(),
            details: vec![],
        }
    }

    pub fn not_found(msg: String) -> Self {
        Self {
            status: StatusCode::NOT_FOUND,
            error: msg,
            details: vec![],
        }
    }

    pub fn internal(msg: String) -> Self {
        Self {
            status: StatusCode::INTERNAL_SERVER_ERROR,
            error: msg,
            details: vec![],
        }
    }

    pub fn validation_error(errors: Vec<String>) -> Self {
        Self {
            status: StatusCode::UNPROCESSABLE_ENTITY,
            error: "Validation failed".into(),
            details: errors,
        }
    }
}

impl IntoResponse for ApiError {
    fn into_response(self) -> Response {
        let body = serde_json::to_string(&self)
            .unwrap_or_else(|_| r#"{"error":"Internal server error"}"#.to_string());
        (self.status, [("content-type", "application/json")], body).into_response()
    }
}

/// Route information collected by proc macros
/// Response model shaping options for FastAPI-like response_model control
#[derive(Clone)]
pub struct ResponseModelOptions {
    /// Fields to include in the response (takes precedence over exclude)
    pub include: Option<&'static [&'static str]>,
    /// Fields to exclude from the response
    pub exclude: Option<&'static [&'static str]>,
    /// Whether to use alias names (from serde(rename)) for serialization
    pub by_alias: bool,
    /// Content-Type override for OpenAPI response
    pub content_type: Option<&'static str>,
}

impl Default for ResponseModelOptions {
    fn default() -> Self {
        ResponseModelOptions {
            include: None,
            exclude: None,
            by_alias: false,
            content_type: None,
        }
    }
}

/// Response class types for specifying different response content types
/// Similar to FastAPI's response_class parameter
#[derive(Clone, Debug, PartialEq, Eq)]
pub enum ResponseClass {
    /// Default JSON response (application/json)
    Json,
    /// HTML response (text/html)
    Html,
    /// Plain text response (text/plain)
    Text,
    /// Binary/octet-stream response (application/octet-stream)
    Binary,
    /// Streaming response (application/octet-stream with chunked transfer)
    Stream,
    /// XML response (application/xml)
    Xml,
    /// File response with optional filename and content-type (application/octet-stream default)
    File,
    /// Redirect response (text/html with Location header)
    Redirect,
}

impl Default for ResponseClass {
    fn default() -> Self {
        ResponseClass::Json
    }
}

impl ResponseClass {
    /// Get the content-type header value for this response class
    pub fn content_type(&self) -> &'static str {
        match self {
            ResponseClass::Json => "application/json",
            ResponseClass::Html => "text/html",
            ResponseClass::Text => "text/plain",
            ResponseClass::Binary => "application/octet-stream",
            ResponseClass::Stream => "application/octet-stream",
            ResponseClass::Xml => "application/xml",
            ResponseClass::File => "application/octet-stream",
            // OpenAPI 用の最小対応（redirect は通常 body を持たない）
            ResponseClass::Redirect => "application/json",
        }
    }
}

/// ファイルレスポンス用型
/// 
/// `#[response_class("file")]` が指定されたエンドポイントの返り値として使用します。
/// 以下の機能を提供します:
/// - ファイルのバイト列（Vec<u8>）
/// - オプションのファイル名（Content-Disposition header で attachment; filename="..." を付与）
/// - オプションの content-type（指定がない場合は application/octet-stream）
/// 
/// # Example
/// 
/// ```ignore
/// use ultraapi::prelude::*;
/// 
/// #[get("/download")]
/// #[response_class("file")]
/// async fn download_file() -> FileResponse {
///     FileResponse::new(vec![0x00, 0x01, 0x02])
///         .filename("example.bin")
///         .content_type("application/octet-stream")
/// }
/// ```
#[derive(Clone, Debug)]
pub struct FileResponse {
    /// ファイルのバイト列
    bytes: Vec<u8>,
    /// ファイル名（Content-Disposition header 用）
    filename: Option<String>,
    /// Content-Type（指定がない場合は application/octet-stream）
    content_type: Option<String>,
}

impl FileResponse {
    /// 新しい FileResponse を作成
    pub fn new(bytes: Vec<u8>) -> Self {
        Self {
            bytes,
            filename: None,
            content_type: None,
        }
    }

    /// ファイル名を設定
    pub fn filename(mut self, filename: impl Into<String>) -> Self {
        self.filename = Some(filename.into());
        self
    }

    /// Content-Type を設定
    pub fn with_content_type(mut self, content_type: impl Into<String>) -> Self {
        self.content_type = Some(content_type.into());
        self
    }

    /// バイト列を取得
    pub fn into_bytes(self) -> Vec<u8> {
        self.bytes
    }

    /// バイト列を参照で取得
    pub fn bytes(&self) -> &Vec<u8> {
        &self.bytes
    }

    /// ファイル名を取得
    pub fn get_filename(&self) -> Option<&String> {
        self.filename.as_ref()
    }

    /// Content-Type を取得（指定がない場合はデフォルト値を返す）
    pub fn get_content_type(&self) -> &str {
        self.content_type.as_deref().unwrap_or("application/octet-stream")
    }
}

impl From<Vec<u8>> for FileResponse {
    fn from(bytes: Vec<u8>) -> Self {
        Self::new(bytes)
    }
}

impl IntoResponse for FileResponse {
    fn into_response(self) -> Response {
        // Get content_type before consuming self.bytes
        let content_type = self.get_content_type().to_string();
        let filename = self.filename.clone();
        
        let mut response = axum::response::Response::new(self.bytes.into());
        
        // Content-Type を設定
        response.headers_mut().insert(
            axum::http::header::CONTENT_TYPE,
            content_type.parse().unwrap_or_else(|_| "application/octet-stream".parse().unwrap()),
        );
        
        // filename が指定されていれば Content-Disposition を設定
        if let Some(filename) = &filename {
            let disposition = format!("attachment; filename=\"{}\"", filename);
            response.headers_mut().insert(
                axum::http::header::CONTENT_DISPOSITION,
                disposition.parse().unwrap(),
            );
        }
        
        response
    }
}

/// リダイレクトレスポンス用型
///
/// `#[response_class("redirect")]` が指定されたエンドポイントの返り値として使用します。
/// `Location` ヘッダーを付与し、既定で 307 (Temporary Redirect) を返します。
#[derive(Clone, Debug)]
pub struct RedirectResponse {
    location: String,
    status: StatusCode,
}

impl RedirectResponse {
    pub fn new(location: impl Into<String>) -> Self {
        Self {
            location: location.into(),
            status: StatusCode::TEMPORARY_REDIRECT,
        }
    }

    pub fn location(mut self, location: impl Into<String>) -> Self {
        self.location = location.into();
        self
    }

    pub fn status(mut self, status: u16) -> Self {
        self.status = StatusCode::from_u16(status).unwrap_or(StatusCode::TEMPORARY_REDIRECT);
        self
    }

    pub fn status_code(mut self, status: StatusCode) -> Self {
        self.status = status;
        self
    }

    pub fn get_location(&self) -> &str {
        &self.location
    }

    pub fn get_status(&self) -> StatusCode {
        self.status
    }
}

impl IntoResponse for RedirectResponse {
    fn into_response(self) -> Response {
        let mut res = axum::response::Response::new(axum::body::Body::empty());
        *res.status_mut() = self.status;
        res.headers_mut().insert(
            axum::http::header::LOCATION,
            self.location
                .parse()
                .unwrap_or_else(|_| "/".parse().unwrap()),
        );
        res
    }
}

/// ストリームレスポンス用型
/// 
/// FastAPI の `StreamingResponse` と同等の機能を提供.
/// 任意のストリームを HTTP レスポンスとして返す際に使用.
/// 
/// # 特徴
/// - 任意の `impl Stream<Item = Result<Bytes, E>>` または `impl Stream<Item = Bytes>` を受け取る
/// - Content-Type（media_type）の指定が可能
/// - カスタムヘッダの追加が可能
/// - ステータスコードの指定が可能
/// - エラーハンドリング: ストリーム内のエラーはログに出力され,接続は閉じられる
/// 
/// # Example
/// 
/// ```ignore
/// use ultraapi::prelude::*;
/// use tokio_stream::iter;
/// 
/// #[get("/stream")]
/// #[response_class("stream")]
/// async fn stream_handler() -> StreamingResponse {
///     let stream = iter([
///         Ok::<_, std::convert::Infallible>(Bytes::from("chunk1\n")),
///         Ok(Bytes::from("chunk2\n")),
///         Ok(Bytes::from("chunk3\n")),
///     ]);
///     StreamingResponse::new(stream)
///         .content_type("text/plain")
/// }
/// 
/// // .from_stream() を使用して errorless ストリームからも作成可能
/// #[get("/stream/text")]
/// #[response_class("stream")]
/// async fn text_stream() -> StreamingResponse {
///     let stream = iter([
///         Bytes::from("line1\n"),
///         Bytes::from("line2\n"),
///         Bytes::from("line3\n"),
///     ]);
///     StreamingResponse::from_stream(stream)
///         .content_type("text/plain")
/// }
/// ```
pub struct StreamingResponse {
    stream: Option<Pin<Box<dyn tokio_stream::Stream<Item = Result<bytes::Bytes, Box<dyn std::error::Error + Send + Sync>>> + Send>>>,
    content_type: Option<String>,
    headers: Vec<(axum::http::HeaderName, axum::http::HeaderValue)>,
    status: StatusCode,
}

// Manual Debug implementation since we can't derive with the stream field
impl std::fmt::Debug for StreamingResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("StreamingResponse")
            .field("stream", &"<stream>")
            .field("content_type", &self.content_type)
            .field("headers", &self.headers)
            .field("status", &self.status)
            .finish()
    }
}

impl StreamingResponse {
    /// 新しい StreamingResponse を作成
    /// 
    /// ストリームは `Result<Bytes, E>` を emit する. エラーが発生した場合はログに出力され,
    /// 接続は閉じられる.
    pub fn new<S, E>(stream: S) -> Self
    where
        S: tokio_stream::Stream<Item = Result<bytes::Bytes, E>> + Send + 'static,
        E: std::error::Error + Send + Sync + 'static,
    {
        // Convert the error type to Box<dyn Error>
        let mapped_stream = TryStreamExt::map_ok(stream, |b| b)
            .map_err(|e| -> Box<dyn std::error::Error + Send + Sync> {
                Box::new(e)
            });
        
        Self {
            stream: Some(Box::pin(mapped_stream)),
            content_type: None,
            headers: Vec::new(),
            status: StatusCode::OK,
        }
    }

    /// ストリームから StreamingResponse を作成（エラーハンドリングなし）
    /// 
    /// このメソッドは `Stream<Item = Bytes>` 用の便利コンストラクタ.
    /// エラーが発生しないストリームに使用する.
    pub fn from_stream<S>(stream: S) -> Self
    where
        S: tokio_stream::Stream<Item = bytes::Bytes> + Send + 'static,
    {
        // Convert regular stream to Result stream
        let mapped_stream = StreamExt::map(stream, |b| -> Result<bytes::Bytes, Box<dyn std::error::Error + Send + Sync>> {
            Ok(b)
        });
        
        Self {
            stream: Some(Box::pin(mapped_stream)),
            content_type: None,
            headers: Vec::new(),
            status: StatusCode::OK,
        }
    }

    /// エラーの発生し得ないストリームから StreamingResponse を作成
    /// 
    /// `Stream<Item = Result<Bytes, Infallible>>` 用のコンストラクタ.
    pub fn from_infallible_stream<S>(stream: S) -> Self
    where
        S: tokio_stream::Stream<Item = Result<bytes::Bytes, std::convert::Infallible>> + Send + 'static,
    {
        // Infallible means the stream can never error, so we can unwrap safely
        let mapped_stream = StreamExt::map(stream, |result| result.map_err(|never| match never {}));
        
        Self {
            stream: Some(Box::pin(mapped_stream)),
            content_type: None,
            headers: Vec::new(),
            status: StatusCode::OK,
        }
    }

    /// Content-Type を設定
    pub fn content_type(mut self, content_type: impl Into<String>) -> Self {
        self.content_type = Some(content_type.into());
        self
    }

    /// ヘッダを追加
    pub fn header(mut self, name: impl TryInto<axum::http::HeaderName>, value: impl TryInto<axum::http::HeaderValue>) -> Self {
        if let (Ok(name), Ok(value)) = (name.try_into(), value.try_into()) {
            self.headers.push((name, value));
        }
        self
    }

    /// ステータスコードを設定
    pub fn status(mut self, status: impl TryInto<StatusCode>) -> Self {
        if let Ok(status) = status.try_into() {
            self.status = status;
        }
        self
    }

    /// ステータスコードを設定（u16 からの変換）
    pub fn status_code(mut self, status: u16) -> Self {
        if let Ok(status) = StatusCode::from_u16(status) {
            self.status = status;
        }
        self
    }

    fn into_response_with_stream(self) -> Response {
        let content_type = self.content_type
            .unwrap_or_else(|| "application/octet-stream".to_string());
        let status = self.status;
        
        // Create a stream that logs errors and converts to http-body compatible stream
        let stream = self.stream.unwrap();
        
        // Use a futures stream that http-body can consume
        // This creates a stream of Result<Bytes, Box<dyn Error>>
        let body_stream = StreamExt::map(stream, |result: Result<bytes::Bytes, Box<dyn std::error::Error + Send + Sync>>| -> Result<bytes::Bytes, Box<dyn std::error::Error + Send + Sync>> {
            match result {
                Ok(bytes) => Ok(bytes),
                Err(e) => {
                    // Log the error - in production this would go to the configured logger
                    eprintln!("StreamingResponse error: {}", e);
                    // Return empty bytes to signal error to the client
                    Ok(bytes::Bytes::new())
                }
            }
        });
        
        // Convert to axum body using Body::from_stream
        let body = axum::body::Body::from_stream(body_stream);
        
        let mut response = Response::new(body);
        *response.status_mut() = status;
        
        // Set content type
        response.headers_mut().insert(
            axum::http::header::CONTENT_TYPE,
            content_type.parse().unwrap_or_else(|_| "application/octet-stream".parse().unwrap()),
        );
        
        // Set custom headers
        for (name, value) in self.headers {
            response.headers_mut().insert(name, value);
        }
        
        response
    }
}

impl IntoResponse for StreamingResponse {
    fn into_response(self) -> Response {
        self.into_response_with_stream()
    }
}

/// Cookie オプション（Set-Cookie の属性）
#[derive(Clone, Debug, Default)]
pub struct CookieOptions {
    http_only: bool,
    secure: bool,
    same_site: Option<&'static str>,
    path: Option<String>,
    max_age: Option<i64>,
    expires: Option<time::OffsetDateTime>,
}

impl CookieOptions {
    pub fn http_only(mut self) -> Self {
        self.http_only = true;
        self
    }

    pub fn secure(mut self) -> Self {
        self.secure = true;
        self
    }

    pub fn same_site_lax(mut self) -> Self {
        self.same_site = Some("Lax");
        self
    }

    pub fn same_site_strict(mut self) -> Self {
        self.same_site = Some("Strict");
        self
    }

    pub fn same_site_none(mut self) -> Self {
        self.same_site = Some("None");
        self
    }

    pub fn path(mut self, path: impl Into<String>) -> Self {
        self.path = Some(path.into());
        self
    }

    pub fn max_age(mut self, seconds: i64) -> Self {
        self.max_age = Some(seconds);
        self
    }

    pub fn expires(mut self, expires: time::OffsetDateTime) -> Self {
        self.expires = Some(expires);
        self
    }
}

/// JSON ボディに Set-Cookie を付与するレスポンスラッパ
#[derive(Clone, Debug)]
pub struct CookieResponse<T> {
    body: T,
    cookies: Vec<(String, String, CookieOptions)>,
}

impl<T> CookieResponse<T> {
    pub fn new(body: T) -> Self {
        Self {
            body,
            cookies: Vec::new(),
        }
    }

    pub fn cookie(mut self, name: &str, value: &str) -> Self {
        self.cookies
            .push((name.to_string(), value.to_string(), CookieOptions::default()));
        self
    }

    pub fn cookie_options<F>(mut self, name: &str, value: &str, f: F) -> Self
    where
        F: FnOnce(CookieOptions) -> CookieOptions,
    {
        let opts = f(CookieOptions::default());
        self.cookies.push((name.to_string(), value.to_string(), opts));
        self
    }
}

impl<T: serde::Serialize> IntoResponse for CookieResponse<T> {
    fn into_response(self) -> Response {
        let body = serde_json::to_string(&self.body)
            .unwrap_or_else(|_| r#"{"error":"Internal server error"}"#.to_string());
        let mut res = (
            StatusCode::OK,
            [("content-type", "application/json")],
            body,
        )
            .into_response();

        for (name, value, opts) in self.cookies {
            let mut cookie = format!("{}={}", name, value);

            if let Some(path) = &opts.path {
                cookie.push_str(&format!("; Path={}", path));
            }
            if let Some(max_age) = opts.max_age {
                cookie.push_str(&format!("; Max-Age={}", max_age));
            }
            if let Some(expires) = opts.expires {
                let formatted = expires
                    .format(&time::format_description::well_known::Rfc2822)
                    .unwrap_or_else(|_| expires.to_string());
                cookie.push_str(&format!("; Expires={}", formatted));
            }
            if let Some(ss) = opts.same_site {
                cookie.push_str(&format!("; SameSite={}", ss));
            }
            if opts.secure {
                cookie.push_str("; Secure");
            }
            if opts.http_only {
                cookie.push_str("; HttpOnly");
            }

            res.headers_mut().append(
                axum::http::header::SET_COOKIE,
                cookie.parse().unwrap(),
            );
        }

        res
    }
}

impl ResponseModelOptions { 
    /// Apply response model shaping to a serde_json::Value
    /// This method handles include/exclude filtering only (no alias conversion)
    pub fn apply(&self, value: serde_json::Value) -> serde_json::Value {
        self.apply_with_aliases(value, None, false)
    }

    /// Apply response model shaping with alias support
    /// 
    /// Steps:
    /// 1. If aliases provided, normalize keys from alias names to field names
    /// 2. Apply include/exclude filtering using field names
    /// 3. If by_alias=true, convert field names back to alias names for output
    /// 
    /// # Arguments
    /// * `value` - The JSON value to transform
    /// * `type_name` - Optional type name to look up alias mappings
    /// * `by_alias` - Whether to use alias names in output (true) or field names (false)
    pub fn apply_with_aliases(&self, value: serde_json::Value, type_name: Option<&str>, by_alias: bool) -> serde_json::Value {
        // Get alias mapping if type_name provided
        let aliases = type_name.and_then(|tn| get_field_aliases(tn));
        
        // Build reverse mapping (alias -> field_name)
        let reverse_aliases: std::collections::HashMap<String, String> = aliases
            .as_ref()
            .map(|a| a.iter().map(|(k, v)| (v.clone(), k.clone())).collect())
            .unwrap_or_default();
        
        // If we have aliases, serde serialized with aliases, so we need to convert
        let has_aliases = !reverse_aliases.is_empty();
        
        match value {
            serde_json::Value::Object(map) => {
                let mut result = serde_json::Map::new();
                
                for (key, val) in map {
                    // Step 1: Normalize key to field name if we have aliases
                    let field_name = if has_aliases {
                        // Try to find field name from alias, fall back to key if not found
                        reverse_aliases.get(&key).cloned().unwrap_or_else(|| key.clone())
                    } else {
                        key.clone()
                    };
                    
                    // Step 2: Apply include/exclude using field names
                    let should_include = match (&self.include, &self.exclude) {
                        // If include is specified, only include those fields
                        (Some(include_list), _) => {
                            include_list.iter().any(|f| *f == field_name.as_str())
                        }
                        // If only exclude is specified, exclude listed fields
                        (None, Some(exclude_list)) => {
                            !exclude_list.iter().any(|f| *f == field_name.as_str())
                        },
                        // No filtering
                        (None, None) => true,
                    };
                    
                    if should_include {
                        // Recursively apply to nested objects
                        let transformed_val = self.apply_with_aliases(val, type_name, by_alias);
                        
                        // Step 3: Convert output key based on by_alias setting
                        let output_key = if by_alias && has_aliases {
                            // Convert field name back to alias for output
                            aliases
                                .as_ref()
                                .and_then(|a| a.get(&field_name).cloned())
                                .unwrap_or(field_name)
                        } else {
                            // Keep field name
                            field_name
                        };
                        
                        result.insert(output_key, transformed_val);
                    }
                }
                
                serde_json::Value::Object(result)
            }
            // For arrays, apply to each element
            serde_json::Value::Array(arr) => {
                serde_json::Value::Array(arr.into_iter().map(|v| self.apply_with_aliases(v, type_name, by_alias)).collect())
            }
            // Other values pass through unchanged
            other => other,
        }
    }
}

pub struct RouteInfo {
    pub path: &'static str,
    pub axum_path: &'static str,
    pub method: &'static str,
    pub handler_name: &'static str,
    pub response_type_name: &'static str,
    pub is_result_return: bool,
    pub is_vec_response: bool,
    pub is_sse: bool,
    pub is_websocket: bool,
    pub vec_inner_type_name: &'static str,
    pub parameters: &'static [openapi::Parameter],
    pub has_body: bool,
    pub body_type_name: &'static str,
    pub success_status: u16,
    pub description: &'static str,
    pub tags: &'static [&'static str],
    pub security: &'static [&'static str],
    pub query_params_fn: Option<fn() -> Vec<openapi::DynParameter>>,
    /// Response model shaping options (include/exclude/by_alias)
    pub response_model_options: ResponseModelOptions,
    /// Response class for content-type (json, html, text, binary, stream, xml)
    pub response_class: ResponseClass,
    /// Operation summary (short description for OpenAPI)
    pub summary: Option<&'static str>,
    /// Mark route as deprecated in OpenAPI spec
    pub deprecated: bool,
    /// External documentation URL for this route
    pub external_docs_url: Option<&'static str>,
    /// External documentation description
    pub external_docs_description: Option<&'static str>,
    pub register_fn: fn(Router<AppState>) -> Router<AppState>,
    pub method_router_fn: fn() -> axum::routing::MethodRouter<AppState>,
}

inventory::collect!(&'static RouteInfo);

/// OpenAPI Callback information collected via #[callback(...)] attribute.
/// This enables automatic callback registration from route definitions.
pub struct CallbackInfo {
    /// The owner route that this callback is attached to
    pub owner: &'static RouteInfo,
    /// Callback name (e.g., "orderCreated")
    pub name: &'static str,
    /// Callback URL expression (e.g., "{$request.body#/callbackUrl}")
    pub expression: &'static str,
    /// The callback route that handles the callback
    pub route: &'static RouteInfo,
}

inventory::collect!(CallbackInfo);

#[derive(Clone)]
struct ProtectedRoute {
    method: String,
    path_pattern: String,
}

fn is_path_param_segment(segment: &str) -> bool {
    segment.starts_with('{') && segment.ends_with('}')
}

fn path_matches_pattern(pattern: &str, path: &str) -> bool {
    let normalized_pattern = pattern.trim_end_matches('/');
    let normalized_path = path.trim_end_matches('/');

    let pattern_segments: Vec<&str> = normalized_pattern
        .split('/')
        .filter(|s| !s.is_empty())
        .collect();
    let path_segments: Vec<&str> = normalized_path
        .split('/')
        .filter(|s| !s.is_empty())
        .collect();

    if pattern_segments.len() != path_segments.len() {
        return false;
    }

    pattern_segments
        .iter()
        .zip(path_segments.iter())
        .all(|(segment_pattern, segment_path)| {
            is_path_param_segment(segment_pattern) || segment_pattern == segment_path
        })
}

fn route_method_matches(route_method: &str, request_method: &Method) -> bool {
    if route_method.eq_ignore_ascii_case(request_method.as_str()) {
        return true;
    }

    // Axum automatically supports HEAD for GET routes.
    request_method == Method::HEAD && route_method.eq_ignore_ascii_case(Method::GET.as_str())
}

/// Schema information collected by api_model attribute
pub struct SchemaInfo {
    pub name: &'static str,
    pub schema_fn: fn() -> openapi::Schema,
    pub nested_fn: fn() -> std::collections::HashMap<String, openapi::Schema>,
}

inventory::collect!(SchemaInfo);

/// Field alias mapping: field_name -> alias_name
/// Used by response_model shaping to convert between field names and aliases
/// 
/// We store a function that returns the aliases HashMap, since HashMap cannot be
/// constructed in const context but OnceLock can be used for lazy initialization.
pub struct FieldAliasInfo {
    pub type_name: &'static str,
    /// Function that returns the alias mapping for this type
    pub get_aliases: fn() -> &'static std::collections::HashMap<String, String>,
}

inventory::collect!(FieldAliasInfo);

/// Helper to get alias mapping for a type by name
pub fn get_field_aliases(type_name: &str) -> Option<std::collections::HashMap<String, String>> {
    for info in inventory::iter::<FieldAliasInfo> {
        if info.type_name == type_name {
            return Some((info.get_aliases)().clone());
        }
    }
    None
}

/// A resolved route with runtime prefix and merged tags/security
pub struct ResolvedRoute {
    pub route_info: &'static RouteInfo,
    pub prefix: String,
    pub extra_tags: Vec<String>,
    pub extra_security: Vec<String>,
}

impl ResolvedRoute {
    /// Full path = prefix + route's original path
    pub fn full_path(&self) -> String {
        let base = self.route_info.path;
        if self.prefix.is_empty() {
            base.to_string()
        } else {
            format!("{}{}", self.prefix, base)
        }
    }

    /// Full axum path = prefix + route's original axum_path
    pub fn full_axum_path(&self) -> String {
        let base = self.route_info.axum_path;
        if self.prefix.is_empty() {
            base.to_string()
        } else {
            format!("{}{}", self.prefix, base)
        }
    }

    /// Merged tags: router-level + route-level
    pub fn merged_tags(&self) -> Vec<String> {
        let mut tags: Vec<String> = self.extra_tags.clone();
        for t in self.route_info.tags {
            if !tags.contains(&t.to_string()) {
                tags.push(t.to_string());
            }
        }
        tags
    }

    /// Merged security: router-level + route-level
    pub fn merged_security(&self) -> Vec<&str> {
        let mut sec: Vec<&str> = self.extra_security.iter().map(|s| s.as_str()).collect();
        for s in self.route_info.security {
            if !sec.contains(s) {
                sec.push(s);
            }
        }
        sec
    }
}

/// A FastAPI-style router with prefix, shared tags, security, deps, and nested routers
pub struct UltraApiRouter {
    prefix: String,
    routes: Vec<&'static RouteInfo>,
    tags: Vec<String>,
    security: Vec<String>,
    deps: HashMap<TypeId, Arc<dyn Any + Send + Sync>>,
    children: Vec<UltraApiRouter>,
}

impl UltraApiRouter {
    pub fn new(prefix: &str) -> Self {
        Self {
            prefix: prefix.to_string(),
            routes: Vec::new(),
            tags: Vec::new(),
            security: Vec::new(),
            deps: HashMap::new(),
            children: Vec::new(),
        }
    }

    pub fn route(mut self, route: &'static RouteInfo) -> Self {
        self.routes.push(route);
        self
    }

    pub fn tag(mut self, tag: &str) -> Self {
        self.tags.push(tag.to_string());
        self
    }

    pub fn security(mut self, scheme: &str) -> Self {
        self.security.push(scheme.to_string());
        self
    }

    pub fn dep<T: 'static + Send + Sync>(mut self, dep: T) -> Self {
        self.deps.insert(TypeId::of::<T>(), Arc::new(dep));
        self
    }

    pub fn include(mut self, child: UltraApiRouter) -> Self {
        self.children.push(child);
        self
    }

    /// Flatten this router tree into resolved routes, accumulating prefix/tags/security
    pub fn resolve(
        &self,
        parent_prefix: &str,
        parent_tags: &[String],
        parent_security: &[String],
    ) -> Vec<ResolvedRoute> {
        let full_prefix = format!("{}{}", parent_prefix, self.prefix);
        let mut merged_tags: Vec<String> = parent_tags.to_vec();
        for t in &self.tags {
            if !merged_tags.contains(t) {
                merged_tags.push(t.clone());
            }
        }
        let mut merged_security: Vec<String> = parent_security.to_vec();
        for s in &self.security {
            if !merged_security.contains(s) {
                merged_security.push(s.clone());
            }
        }

        let mut resolved = Vec::new();
        for route in &self.routes {
            resolved.push(ResolvedRoute {
                route_info: route,
                prefix: full_prefix.clone(),
                extra_tags: merged_tags.clone(),
                extra_security: merged_security.clone(),
            });
        }
        for child in &self.children {
            resolved.extend(child.resolve(&full_prefix, &merged_tags, &merged_security));
        }
        resolved
    }

    /// Collect all deps from this router tree
    pub fn collect_deps(&self) -> HashMap<TypeId, Arc<dyn Any + Send + Sync>> {
        let mut all = self.deps.clone();
        for child in &self.children {
            all.extend(child.collect_deps());
        }
        all
    }
}

/// Swagger UI serving mode
#[derive(Debug, Clone)]
pub enum SwaggerMode {
    /// Load Swagger UI assets from a CDN URL
    Cdn(String),
    /// Use embedded Scalar API reference (works offline)
    Embedded,
}

/// The main application struct
pub struct UltraApiApp {
    deps: HashMap<TypeId, Arc<dyn Any + Send + Sync>>,
    /// Dependency overrides for testing - these take precedence over regular deps
    dep_overrides: HashMap<TypeId, Arc<dyn Any + Send + Sync>>,
    /// Resolver for Depends function-based dependencies
    depends_resolver: Option<Arc<DependsResolver>>,
    title: String,
    version: String,
    description: Option<String>,
    contact: Option<openapi::Contact>,
    license: Option<openapi::License>,
    swagger_mode: SwaggerMode,
    servers: Vec<openapi::Server>,
    security_schemes: HashMap<String, openapi::SecurityScheme>,
    routers: Vec<UltraApiRouter>,
    /// Middleware configuration
    middleware: MiddlewareBuilder,
    /// Lifecycle hooks (startup/shutdown)
    lifecycle: Lifecycle,
    /// OpenAPI webhooks (not registered in runtime router)
    webhooks: HashMap<String, openapi::PathItem>,
    /// OpenAPI callbacks (attached to owner route's operation)
    /// Key: (owner_route_path, owner_method, callback_name, expression, callback_route)
    callbacks: Vec<(&'static RouteInfo, String, String, &'static RouteInfo)>,
    /// Mounted sub-applications (path, sub_app)
    mounted_apps: Vec<(String, UltraApiApp)>,
    /// Static files directories (path, dir_path)
    static_files: Vec<(String, String)>,
    /// Templates instance for rendering templates
    templates: Option<templates::Templates>,
    /// Global error handler for catching custom exceptions
    error_handler: Option<CustomErrorHandler>,
    /// Catch panics in handlers and convert to 500 responses
    catch_panic: bool,
}

impl Default for UltraApiApp {
    fn default() -> Self {
        Self::new()
    }
}

impl UltraApiApp {
    pub fn new() -> Self {
        Self {
            deps: HashMap::new(),
            dep_overrides: HashMap::new(),
            depends_resolver: None,
            title: env!("CARGO_PKG_NAME").to_string(),
            version: env!("CARGO_PKG_VERSION").to_string(),
            description: None,
            contact: None,
            license: None,
            swagger_mode: SwaggerMode::Embedded,
            servers: Vec::new(),
            security_schemes: HashMap::new(),
            routers: Vec::new(),
            middleware: MiddlewareBuilder::new(),
            lifecycle: Lifecycle::new(),
            webhooks: HashMap::new(),
            callbacks: Vec::new(),
            mounted_apps: Vec::new(),
            static_files: Vec::new(),
            templates: None,
            error_handler: None,
            catch_panic: false,
        }
    }

    pub fn title(mut self, title: &str) -> Self {
        self.title = title.to_string();
        self
    }

    pub fn version(mut self, version: &str) -> Self {
        self.version = version.to_string();
        self
    }

    pub fn description(mut self, desc: &str) -> Self {
        self.description = Some(desc.to_string());
        self
    }

    pub fn contact(mut self, name: &str, email: &str, url: &str) -> Self {
        self.contact = Some(openapi::Contact {
            name: Some(name.to_string()),
            email: Some(email.to_string()),
            url: Some(url.to_string()),
        });
        self
    }

    pub fn license(mut self, name: &str, url: &str) -> Self {
        self.license = Some(openapi::License {
            name: name.to_string(),
            url: Some(url.to_string()),
        });
        self
    }

    pub fn swagger_mode(mut self, mode: SwaggerMode) -> Self {
        self.swagger_mode = mode;
        self
    }

    pub fn swagger_cdn(mut self, url: &str) -> Self {
        self.swagger_mode = SwaggerMode::Cdn(url.to_string());
        self
    }

    pub fn dep<T: 'static + Send + Sync>(mut self, dep: T) -> Self {
        self.deps.insert(TypeId::of::<T>(), Arc::new(dep));
        self
    }

    /// Override a dependency for testing.
    ///
    /// This allows replacing registered dependencies with mock values during testing.
    /// Overrides take precedence over regular dependencies registered via [`dep()`](UltraApiApp::dep).
    ///
    /// # Example
    ///
    /// ```
    /// use ultraapi::prelude::*;
    ///
    /// #[derive(Clone)]
    /// struct DatabasePool {
    ///     dsn: &'static str,
    /// }
    ///
    /// // Use the same type to replace runtime dependency with a test stub.
    /// let app = UltraApiApp::new()
    ///     .dep(DatabasePool { dsn: "postgres://prod" })
    ///     .override_dep(DatabasePool { dsn: "sqlite://:memory:" });
    ///
    /// assert!(app.has_override::<DatabasePool>());
    /// ```
    pub fn override_dep<T: 'static + Send + Sync>(mut self, dep: T) -> Self {
        self.dep_overrides.insert(TypeId::of::<T>(), Arc::new(dep));
        self
    }

    /// Check if a dependency override exists for the given type.
    pub fn has_override<T: 'static + Send + Sync>(&self) -> bool {
        self.dep_overrides.contains_key(&TypeId::of::<T>())
    }

    /// Clear all dependency overrides.
    pub fn clear_overrides(mut self) -> Self {
        self.dep_overrides.clear();
        self
    }

    /// Register a function-based dependency (FastAPI-style Depends).
    ///
    /// The function will be called to resolve the dependency at request time,
    /// with support for nested dependencies through the `Depends` parameter.
    ///
    /// # Example
    ///
    /// ```ignore
    /// use ultraapi::prelude::*;
    ///
    /// // Define a simple dependency function
    /// async fn get_db_pool(state: AppState) -> Result<Arc<DbPool>, DependencyError> {
    ///     state.get::<DbPool>().ok_or_else(|| DependencyError::missing("DbPool"))
    /// }
    ///
    /// // Define a nested dependency that depends on the first
    /// async fn get_user_service(pool: Depends<DbPool>) -> Result<Arc<UserService>, DependencyError> {
    ///     Ok(Arc::new(UserService { pool: (*pool).clone() }))
    /// }
    ///
    /// let app = UltraApiApp::new()
    ///     .dep(DbPool { connection_string: "postgres://localhost".into() })
    ///     .depends(get_db_pool)
    ///     .depends(get_user_service);
    /// ```
    pub fn depends<T, F, R>(mut self, func: F) -> Self
    where
        T: Send + Sync + 'static,
        F: Fn(AppState) -> R + Send + Sync + 'static,
        R: Future<Output = Result<T, DependencyError>> + Send + 'static,
    {
        // Create resolver if not exists
        if self.depends_resolver.is_none() {
            self.depends_resolver = Some(Arc::new(DependsResolver::new()));
        }

        if let Some(ref resolver) = self.depends_resolver {
            let resolver = Arc::clone(resolver);
            resolver.register(std::marker::PhantomData::<T>, func);
        }

        self
    }

    /// Register a callable dependency function that declares its dependencies.
    ///
    /// This enables FastAPI-like dependency chaining where a dependency function
    /// can declare what other dependencies it needs via the `depends_on` parameter.
    ///
    /// # Example
    ///
    /// ```ignore
    /// use ultraapi::prelude::*;
    /// use std::sync::Arc;
    /// use std::any::TypeId;
    ///
    /// #[derive(Clone)]
    /// struct DbPool { connection_string: String }
    ///
    /// #[derive(Clone)]
    /// struct UserRepository { pool: Arc<DbPool> }
    ///
    /// // A dependency that needs another dependency
    /// async fn get_user_repo(state: AppState) -> Result<Arc<UserRepository>, DependencyError> {
    ///     let pool = state.get::<DbPool>().ok_or_else(|| DependencyError::missing("DbPool"))?;
    ///     Ok(Arc::new(UserRepository { pool }))
    /// }
    ///
    /// let app = UltraApiApp::new()
    ///     .dep(DbPool { connection_string: "postgres://localhost".into() })
    ///     .depends_with_deps(get_user_repo, vec![TypeId::of::<DbPool>()]);
    /// ```
    pub fn depends_with_deps<T, F, R>(mut self, func: F, depends_on: Vec<TypeId>) -> Self
    where
        T: Send + Sync + 'static,
        F: Fn(AppState) -> R + Send + Sync + 'static,
        R: Future<Output = Result<T, DependencyError>> + Send + 'static,
    {
        // Create resolver if not exists
        if self.depends_resolver.is_none() {
            self.depends_resolver = Some(Arc::new(DependsResolver::new()));
        }

        if let Some(ref resolver) = self.depends_resolver {
            let resolver = Arc::clone(resolver);
            resolver.register_with_deps(std::marker::PhantomData::<T>, func, depends_on);
        }

        self
    }

    /// Register a yield-based dependency (FastAPI-style generator with cleanup).
    ///
    /// The generator produces a value and runs cleanup when the scope ends.
    /// This is similar to FastAPI's `yield` dependencies.
    ///
    /// # Example
    ///
    /// ```ignore
    /// use ultraapi::prelude::*;
    /// use std::sync::Arc;
    ///
    /// struct DatabasePool {
    ///     connection_string: String,
    /// }
    ///
    /// // Implement Generator for the dependency type
    /// #[async_trait::async_trait]
    /// impl Generator<dyn Any + Send + Sync, Output = Arc<dyn Any + Send + Sync>, Error = DependencyError> for DatabasePool {
    ///     async fn generate(self: Arc<Self>, _scope: Scope) -> Result<Arc<dyn Any + Send + Sync>, DependencyError> {
    ///         Ok(self.clone() as Arc<dyn Any + Send + Sync>)
    ///     }
    ///
    ///     async fn cleanup(self: Arc<Self>) -> Result<(), DependencyError> {
    ///         println!("Cleaning up database pool");
    ///         Ok(())
    ///     }
    /// }
    ///
    /// let app = UltraApiApp::new()
    ///     .yield_depends(Arc::new(DatabasePool { connection_string: "postgres://localhost".into() }), Scope::Request);
    /// ```
    pub fn yield_depends<T, G>(mut self, generator: G, scope: Scope) -> Self
    where
        T: Send + Sync + 'static,
        G: Generator<Output = T, Error = DependencyError> + Send + Sync + 'static,
    {
        // Create resolver if not exists
        if self.depends_resolver.is_none() {
            self.depends_resolver = Some(Arc::new(DependsResolver::new()));
        }

        if let Some(ref resolver) = self.depends_resolver {
            let resolver = Arc::clone(resolver);
            resolver.register_yield(std::marker::PhantomData::<T>, generator, scope);
        }

        self
    }

    /// Get the Depends resolver (for internal use)
    pub fn get_depends_resolver(&self) -> Option<&Arc<DependsResolver>> {
        self.depends_resolver.as_ref()
    }

    pub fn server(mut self, url: &str) -> Self {
        self.servers.push(openapi::Server {
            url: url.to_string(),
        });
        self
    }

    pub fn security_scheme(mut self, name: &str, scheme: openapi::SecurityScheme) -> Self {
        self.security_schemes.insert(name.to_string(), scheme);
        self
    }

    /// Add a webhook to the OpenAPI spec.
    /// 
    /// Webhooks are defined at the API level (not tied to a specific route).
    /// They will appear in the `webhooks` section of the OpenAPI spec.
    ///
    /// Note: whether the underlying route is available at runtime depends on routing mode.
    /// With explicit routing (`.include(...)`), only included routes are registered.
    /// With implicit routing (inventory auto-registration), any `#[get]`/`#[post]` route may be registered.
    ///
    /// # Example
    /// ```ignore
    /// use ultraapi::prelude::*;
    /// use ultraapi::{RouteInfo, route};
    ///
    /// // Define a webhook route (won't be registered in router)
    /// static WEBHOOK_ROUTE: RouteInfo = route!(GET "/webhook/payment" -> PaymentEvent, tags = ["webhooks"]);
    ///
    /// let app = UltraApiApp::new()
    ///     .webhook("paymentWebhook", &WEBHOOK_ROUTE);
    /// ```
    pub fn webhook(mut self, name: &str, route: &'static RouteInfo) -> Self {
        let tags: Vec<String> = route.tags.iter().map(|s| s.to_string()).collect();
        let sec: Vec<&str> = route.security.to_vec();
        let operation = Self::build_operation(route, tags, &sec);
        let mut path_item = openapi::PathItem::new();
        path_item.insert(route.method.to_lowercase(), operation);
        self.webhooks.insert(name.to_string(), path_item);
        self
    }

    /// Add a callback to an existing route's OpenAPI operation.
    /// 
    /// Callbacks are attached to a specific owner route and will appear in the
    /// `callbacks` section of that route's operation in the OpenAPI spec.
    ///
    /// Note: whether the callback route is available at runtime depends on routing mode.
    /// With explicit routing (`.include(...)`), only included routes are registered.
    /// With implicit routing (inventory auto-registration), any `#[get]`/`#[post]` route may be registered.
    ///
    /// # Example
    /// ```ignore
    /// use ultraapi::prelude::*;
    /// use ultraapi::{RouteInfo, route};
    ///
    /// static OWNER_ROUTE: RouteInfo = route!(POST "/subscriptions" -> Subscription, tags = ["subscriptions"]);
    /// static CALLBACK_ROUTE: RouteInfo = route!(POST "/webhook/subscription" -> SubscriptionEvent, tags = ["callbacks"]);
    ///
    /// let app = UltraApiApp::new()
    ///     .callback(&OWNER_ROUTE, "subscriptionEvent", "{$request.body#/callbackUrl}", &CALLBACK_ROUTE);
    /// ```
    pub fn callback(
        mut self,
        owner: &'static RouteInfo,
        callback_name: &str,
        expression: &str,
        callback_route: &'static RouteInfo,
    ) -> Self {
        self.callbacks.push((
            owner,
            callback_name.to_string(),
            expression.to_string(),
            callback_route,
        ));
        self
    }

    pub fn bearer_auth(self) -> Self {
        self.security_scheme(
            "bearerAuth",
            openapi::SecurityScheme::Bearer {
                bearer_format: None,
            },
        )
    }

    /// Add HTTP Basic security scheme to the OpenAPI specification
    /// 
    /// # Example
    /// 
    /// ```ignore
    /// use ultraapi::prelude::*;
    /// 
    /// let app = UltraApiApp::new()
    ///     .title("Secure API")
    ///     .version("0.1.0")
    ///     .basic_auth();
    /// ```
    pub fn basic_auth(self) -> Self {
        self.security_scheme(
            "basicAuth",
            openapi::SecurityScheme::Basic {
                realm: Some("UltraAPI".to_string()),
            },
        )
    }

    /// Add OAuth2 security scheme with implicit flow
    ///
    /// # Example
    /// ```
    /// use ultraapi::prelude::*;
    ///
    /// let app = UltraApiApp::new()
    ///     .oauth2_implicit(
    ///         "oauth2Implicit",
    ///         "https://example.com/authorize",
    ///         [
    ///             ("read", "Read access"),
    ///             ("write", "Write access"),
    ///         ],
    ///     );
    /// ```
    pub fn oauth2_implicit<'a>(
        mut self,
        name: &str,
        authorization_url: &str,
        scopes: impl IntoIterator<Item = (&'a str, &'a str)>,
    ) -> Self {
        let mut scope_map = std::collections::HashMap::new();
        for (key, desc) in scopes {
            scope_map.insert(key.to_string(), desc.to_string());
        }
        let flow = openapi::OAuth2Flow {
            authorization_url: Some(authorization_url.to_string()),
            token_url: None,
            refresh_url: None,
            scopes: scope_map,
        };
        let mut flows = openapi::OAuth2Flows::default();
        flows.implicit = Some(flow);
        self.security_schemes.insert(
            name.to_string(),
            openapi::SecurityScheme::OAuth2(flows),
        );
        self
    }

    /// Add OAuth2 security scheme with password flow
    ///
    /// # Example
    /// ```
    /// use ultraapi::prelude::*;
    ///
    /// let app = UltraApiApp::new()
    ///     .oauth2_password(
    ///         "oauth2Password",
    ///         "https://example.com/token",
    ///         [
    ///             ("read", "Read access"),
    ///             ("write", "Write access"),
    ///         ],
    ///     );
    /// ```
    pub fn oauth2_password<'a>(
        mut self,
        name: &str,
        token_url: &str,
        scopes: impl IntoIterator<Item = (&'a str, &'a str)>,
    ) -> Self {
        let mut scope_map = std::collections::HashMap::new();
        for (key, desc) in scopes {
            scope_map.insert(key.to_string(), desc.to_string());
        }
        let flow = openapi::OAuth2Flow {
            authorization_url: None,
            token_url: Some(token_url.to_string()),
            refresh_url: None,
            scopes: scope_map,
        };
        let mut flows = openapi::OAuth2Flows::default();
        flows.password = Some(flow);
        self.security_schemes.insert(
            name.to_string(),
            openapi::SecurityScheme::OAuth2(flows),
        );
        self
    }

    /// Add OAuth2 security scheme with client credentials flow
    ///
    /// # Example
    /// ```
    /// use ultraapi::prelude::*;
    ///
    /// let app = UltraApiApp::new()
    ///     .oauth2_client_credentials(
    ///         "oauth2ClientCredentials",
    ///         "https://example.com/token",
    ///         [
    ///             ("read", "Read access"),
    ///             ("write", "Write access"),
    ///         ],
    ///     );
    /// ```
    pub fn oauth2_client_credentials<'a>(
        mut self,
        name: &str,
        token_url: &str,
        scopes: impl IntoIterator<Item = (&'a str, &'a str)>,
    ) -> Self {
        let mut scope_map = std::collections::HashMap::new();
        for (key, desc) in scopes {
            scope_map.insert(key.to_string(), desc.to_string());
        }
        let flow = openapi::OAuth2Flow {
            authorization_url: None,
            token_url: Some(token_url.to_string()),
            refresh_url: None,
            scopes: scope_map,
        };
        let mut flows = openapi::OAuth2Flows::default();
        flows.client_credentials = Some(flow);
        self.security_schemes.insert(
            name.to_string(),
            openapi::SecurityScheme::OAuth2(flows),
        );
        self
    }

    /// Add OAuth2 security scheme with authorization code flow
    ///
    /// # Example
    /// ```
    /// use ultraapi::prelude::*;
    ///
    /// let app = UltraApiApp::new()
    ///     .oauth2_authorization_code(
    ///         "oauth2AuthCode",
    ///         "https://example.com/authorize",
    ///         "https://example.com/token",
    ///         [
    ///             ("read", "Read access"),
    ///             ("write", "Write access"),
    ///         ],
    ///     );
    /// ```
    pub fn oauth2_authorization_code<'a>(
        mut self,
        name: &str,
        authorization_url: &str,
        token_url: &str,
        scopes: impl IntoIterator<Item = (&'a str, &'a str)>,
    ) -> Self {
        let mut scope_map = std::collections::HashMap::new();
        for (key, desc) in scopes {
            scope_map.insert(key.to_string(), desc.to_string());
        }
        let flow = openapi::OAuth2Flow {
            authorization_url: Some(authorization_url.to_string()),
            token_url: Some(token_url.to_string()),
            refresh_url: None,
            scopes: scope_map,
        };
        let mut flows = openapi::OAuth2Flows::default();
        flows.authorization_code = Some(flow);
        self.security_schemes.insert(
            name.to_string(),
            openapi::SecurityScheme::OAuth2(flows),
        );
        self
    }

    /// Add OAuth2 security scheme with multiple flows
    ///
    /// # Example
    /// ```
    /// use ultraapi::prelude::*;
    /// use ultraapi::openapi::{OAuth2Flow, OAuth2Flows};
    ///
    /// let mut flows = OAuth2Flows::default();
    /// flows.authorization_code = Some(OAuth2Flow {
    ///     authorization_url: Some("https://example.com/authorize".to_string()),
    ///     token_url: Some("https://example.com/token".to_string()),
    ///     refresh_url: None,
    ///     scopes: [("read".to_string(), "Read access".to_string())].into(),
    /// });
    ///
    /// let app = UltraApiApp::new()
    ///     .oauth2("oauth2Multi", flows);
    /// ```
    pub fn oauth2(mut self, name: &str, flows: openapi::OAuth2Flows) -> Self {
        self.security_schemes
            .insert(name.to_string(), openapi::SecurityScheme::OAuth2(flows));
        self
    }

    /// Add OpenID Connect security scheme
    ///
    /// # Example
    /// ```
    /// use ultraapi::prelude::*;
    ///
    /// let app = UltraApiApp::new()
    ///     .openid_connect("oidc", "https://example.com/.well-known/openid-configuration");
    /// ```
    pub fn openid_connect(mut self, name: &str, url: &str) -> Self {
        self.security_schemes.insert(
            name.to_string(),
            openapi::SecurityScheme::OpenIdConnect {
                url: url.to_string(),
            },
        );
        self
    }

    /// Add API key security scheme
    ///
    /// # Example
    /// ```
    /// use ultraapi::prelude::*;
    ///
    /// let app = UltraApiApp::new()
    ///     .api_key("apiKeyAuth", "X-API-Key", "header");
    /// ```
    pub fn api_key(mut self, name: &str, key_name: &str, location: &str) -> Self {
        self.security_schemes.insert(
            name.to_string(),
            openapi::SecurityScheme::ApiKey {
                name: key_name.to_string(),
                location: location.to_string(),
            },
        );
        self
    }

    pub fn include(mut self, router: UltraApiRouter) -> Self {
        self.routers.push(router);
        self
    }

    /// Configure middleware for the application
    ///
    /// # Example
    /// ```
    /// use ultraapi::prelude::*;
    ///
    /// let app = UltraApiApp::new()
    ///     .middleware(|builder| {
    ///         builder
    ///             .enable_auth()  // Enforce #[security] routes
    ///             .cors(CorsConfig::new())
    ///     });
    /// ```
    pub fn middleware<F>(mut self, f: F) -> Self
    where
        F: FnOnce(MiddlewareBuilder) -> MiddlewareBuilder,
    {
        self.middleware = f(MiddlewareBuilder::new());
        self
    }

    /// Configure lifecycle hooks (startup/shutdown)
    ///
    /// # Example
    /// ```
    /// use ultraapi::prelude::*;
    ///
    /// let app = UltraApiApp::new()
    ///     .lifecycle(|lifecycle| {
    ///         lifecycle
    ///             .on_startup(|state| {
    ///                 Box::pin(async {
    ///                     println!("Starting up!");
    ///                 })
    ///             })
    ///             .on_shutdown(|state| {
    ///                 Box::pin(async {
    ///                     println!("Shutting down!");
    ///                 })
    ///             })
    ///     });
    /// ```
    pub fn lifecycle<F>(mut self, f: F) -> Self
    where
        F: FnOnce(Lifecycle) -> Lifecycle,
    {
        self.lifecycle = f(Lifecycle::new());
        self
    }

    /// Get a reference to the lifecycle hooks
    pub fn lifecycle_hooks(&self) -> &Lifecycle {
        &self.lifecycle
    }

    /// Mount a sub-application at the given path.
    /// 
    /// This is similar to FastAPI's sub-applications. The sub-app will have its own
    /// `/docs` and `/openapi.json` endpoints available at `/<path>/docs` and `/<path>/openapi.json`.
    /// 
    /// Note: The sub-app's routes will NOT be included in the main app's OpenAPI spec.
    /// The sub-app's deps will be merged into the main app's dependency injection container.
    /// 
    /// # Example
    /// 
    /// ```ignore
    /// use ultraapi::prelude::*;
    /// 
    /// // Create a sub-app
    /// let sub_app = UltraApiApp::new()
    ///     .title("Sub API")
    ///     .version("1.0.0");
    /// 
    /// // Mount it at /api
    /// let app = UltraApiApp::new()
    ///     .mount("/api", sub_app);
    /// ```
    pub fn mount(mut self, path: &str, mut sub_app: UltraApiApp) -> Self {
        // Merge sub-app's deps into main app
        for (type_id, dep) in sub_app.deps.drain() {
            self.deps.insert(type_id, dep);
        }
        self.mounted_apps.push((path.to_string(), sub_app));
        self
    }

    /// Serve static files from a directory.
    /// 
    /// # Example
    /// 
    /// ```ignore
    /// use ultraapi::prelude::*;
    /// 
    /// let app = UltraApiApp::new()
    ///     .static_files("/static", "./static");
    /// ```
    pub fn static_files(mut self, path: &str, dir: impl Into<String>) -> Self {
        self.static_files.push((path.to_string(), dir.into()));
        self
    }

    /// Set the templates directory for rendering HTML templates.
    /// 
    /// The templates will be registered as a dependency that can be injected via `Dep<Templates>`.
    /// 
    /// # Example
    /// 
    /// ```ignore
    /// use ultraapi::prelude::*;
    /// 
    /// let app = UltraApiApp::new()
    ///     .templates_dir("./templates");
    /// 
    /// // In a handler
    /// #[get("/hello")]
    /// async fn hello(templates: Dep<Templates>) -> impl IntoResponse {
    ///     template_response(&templates, "hello.html", serde_json::json!({ "name": "World" }))
    /// }
    /// ```
    pub fn templates_dir(mut self, dir: impl AsRef<Path>) -> Self {
        match templates::Templates::new(dir) {
            Ok(templates) => {
                self.templates = Some(templates);
                self
            }
            Err(e) => {
                // For now, we'll just log and continue without templates
                // In production, you might want to handle this differently
                eprintln!("Warning: Failed to load templates: {}", e);
                self
            }
        }
    }

    /// Register a global error handler.
    ///
    /// The handler can inspect the request context and error payload, then return any response.
    pub fn error_handler_from_arc(mut self, handler: CustomErrorHandler) -> Self {
        self.error_handler = Some(handler);
        self
    }

    /// Register a global error handler from a closure.
    pub fn error_handler<F, Fut, R>(mut self, f: F) -> Self
    where
        F: Fn(
                AppState,
                axum::http::Request<axum::body::Body>,
                Box<dyn std::any::Any + Send + 'static>,
            ) -> Fut
            + Send
            + Sync
            + 'static,
        Fut: std::future::Future<Output = R> + Send + 'static,
        R: IntoResponse,
    {
        let handler: CustomErrorHandler = Arc::new(move |state, req, err| {
            let fut = f(state, req, err);
            Box::pin(async move { fut.await.into_response() })
        });
        self.error_handler = Some(handler);
        self
    }

    /// Enable panic catching (convert panics into 500 Internal Server Error).
    pub fn catch_panic(mut self) -> Self {
        self.catch_panic = true;
        self
    }

    /// Enable gzip compression (default settings).
    ///
    /// This adds response compression using gzip and brotli encoding.
    /// Responses are compressed when:
    /// - The client sends appropriate `Accept-Encoding` header (gzip, br, deflate)
    /// - The response body is larger than the default threshold (1024 bytes)
    ///
    /// Both gzip and brotli are enabled by default.
    ///
    /// # Example
    ///
    /// ```rust
    /// use ultraapi::prelude::*;
    ///
    /// let app = UltraApiApp::new()
    ///     .title("My API")
    ///     .gzip();  // Enable gzip + brotli compression
    /// ```
    pub fn gzip(mut self) -> Self {
        self.middleware.compression(middleware::CompressionConfig::new());
        self
    }

    /// Enable GZip compression with custom configuration (FastAPI-compatible).
    ///
    /// # Example
    ///
    /// ```rust
    /// use ultraapi::prelude::*;
    /// use ultraapi::middleware::GZipConfig;
    ///
    /// let app = UltraApiApp::new()
    ///     .title("My API")
    ///     .gzip_config(GZipConfig::new().minimum_size(512));
    /// ```
    pub fn gzip_config(mut self, config: middleware::GZipConfig) -> Self {
        self.middleware = self.middleware.gzip_config(config);
        self
    }

    /// Enable compression with custom configuration.
    ///
    /// # Example
    ///
    /// ```rust
    /// use ultraapi::prelude::*;
    ///
    /// let app = UltraApiApp::new()
    ///     .title("My API")
    ///     .compression(CompressionConfig::new()
    ///         .gzip(true)
    ///         .brotli(false));  // Only gzip, no brotli
    /// ```
    pub fn compression(mut self, config: middleware::CompressionConfig) -> Self {
        self.middleware.compression(config);
        self
    }

    /// レート制限を有効化します
    ///
    /// デフォルトでは `X-Forwarded-For` ヘッダー（最初のIP）を使用してクライアントを識別します。
    /// ヘッダーが存在しない場合は `"global"` キーが使用されます。
    ///
    /// # Arguments
    ///
    /// * `max_requests` - ウィンドウ内で許可される最大リクエスト数
    /// * `window` - レート制限の時間枠
    ///
    /// # Example
    ///
    /// ```rust
    /// use ultraapi::prelude::*;
    /// use ultraapi::middleware::RateLimitConfig;
    /// use std::time::Duration;
    ///
    /// let app = UltraApiApp::new()
    ///     .title("My API")
    ///     .rate_limit(RateLimitConfig::new(10, Duration::from_secs(60)));
    /// ```
    pub fn rate_limit(mut self, config: middleware::RateLimitConfig) -> Self {
        self.middleware.rate_limit(config);
        self
    }

    /// レート制限を有効化します（簡単なインターフェース）
    ///
    /// # Arguments
    ///
    /// * `max_requests` - ウィンドウ内で許可される最大リクエスト数
    /// * `window_secs` - レート制限の時間枠（秒）
    ///
    /// # Example
    ///
    /// ```rust
    /// use ultraapi::prelude::*;
    /// use ultraapi::middleware::RateLimitConfig;
    /// use std::time::Duration;
    ///
    /// let app = UltraApiApp::new()
    ///     .title("My API")
    ///     .rate_limit(RateLimitConfig::new(10, Duration::from_secs(60)));
    /// ```
    pub fn rate_limit_max(mut self, max_requests: u32, window_secs: u64) -> Self {
        let config = middleware::RateLimitConfig::new(
            max_requests,
            std::time::Duration::from_secs(window_secs),
        );
        self.middleware.rate_limit(config);
        self
    }

    /// Check if routers were explicitly included
    pub fn has_explicit_routes(&self) -> bool {
        !self.routers.is_empty()
    }

    /// Resolve all routes from included routers
    pub fn resolve_routes(&self) -> Vec<ResolvedRoute> {
        let mut resolved = Vec::new();
        for router in &self.routers {
            resolved.extend(router.resolve("", &[], &[]));
        }
        resolved
    }

pub fn into_router(self) -> Router {
        let (router, _runner) = self.into_router_with_lifespan();
        router
    }

    /// Convert the application into a Router with integrated lifespan management
    /// 
    /// This method returns both the Router and a LifespanRunner that manages startup/shutdown hooks.
    /// The Router will automatically run startup hooks on the first request (lazy startup).
    /// The LifespanRunner can be used to trigger shutdown hooks when the application is done.
    /// 
    /// # Example
    /// 
    /// ```ignore
    /// use ultraapi::prelude::*;
    /// 
    /// let app = UltraApiApp::new()
    ///     .on_startup(|_state| {
    ///         Box::pin(async {
    ///             println!("Starting up!");
    ///         })
    ///     })
    ///     .on_shutdown(|_state| {
    ///         Box::pin(async {
    ///             println!("Shutting down!");
    ///         })
    ///     });
    /// 
    /// let (router, runner) = app.into_router_with_lifespan();
    /// 
    /// // Use router for testing or serving...
    /// 
    /// // When done, trigger shutdown:
    /// runner.shutdown().await;
    /// ```
    pub fn into_router_with_lifespan(mut self) -> (Router, lifespan::LifespanRunner) {
        let spec = self.generate_openapi_spec();
        let swagger_html = self.generate_swagger_html();
        let redoc_html = self.generate_redoc_html("/openapi.json");
        let has_explicit = self.has_explicit_routes();
        let resolved = if has_explicit {
            self.resolve_routes()
        } else {
            Vec::new()
        };
        let spec_json =
            serde_json::to_string_pretty(&spec.to_json_with_query_params(&self.routers))
                .expect("Failed to serialize OpenAPI spec");

        // Merge deps from routers
        let mut all_deps = self.deps;
        for router in &self.routers {
            all_deps.extend(router.collect_deps());
        }

        // Apply dependency overrides (they take precedence over regular deps)
        for (type_id, override_val) in self.dep_overrides {
            all_deps.insert(type_id, override_val);
        }

        // Store the depends resolver for later use
        let depends_resolver = self.depends_resolver;

        // Register templates as a dependency if configured
        let templates = self.templates;
        if let Some(tmpl) = templates {
            all_deps.insert(TypeId::of::<templates::Templates>(), Arc::new(tmpl));
        }

        let state = AppState {
            deps: Arc::new(all_deps),
            depends_resolver,
        };

        let mut app = Router::new();

        if has_explicit {
            for r in &resolved {
                let axum_path = r.full_axum_path();
                let method_router = (r.route_info.method_router_fn)();
                app = app.route(&axum_path, method_router);
            }
        } else {
            for route in inventory::iter::<&RouteInfo> {
                app = (route.register_fn)(app);
            }
        }

        let spec_json_clone = spec_json.clone();
        app = app.route(
            "/openapi.json",
            axum::routing::get(move || {
                let spec = spec_json_clone.clone();
                async move { (StatusCode::OK, [("content-type", "application/json")], spec) }
            }),
        );

        app = app.route(
            "/docs",
            axum::routing::get(move || {
                let html = swagger_html.clone();
                async move { (StatusCode::OK, [("content-type", "text/html")], html) }
            }),
        );

        app = app.route(
            "/redoc",
            axum::routing::get(move || {
                let html = redoc_html.clone();
                async move { (StatusCode::OK, [("content-type", "text/html")], html) }
            }),
        );

        // Add static files
        for (path, dir) in &self.static_files {
            let static_service = tower_http::services::ServeDir::new(dir);
            app = app.nest_service(path, static_service);
        }

        // Collect mounted apps before consuming self
        let mounted_apps = std::mem::take(&mut self.mounted_apps);

        // Apply CORS if configured
        if let Some(ref cors_config) = self.middleware.cors_config {
            app = app.layer(cors_config.clone().build());
        }

        // Apply auth middleware if enabled
        if self.middleware.auth_enabled {
            if let Some(auth_layer) = self.middleware.auth_layer.clone() {
                let mut protected_routes: Vec<ProtectedRoute> = Vec::new();

                // Collect protected routes from explicit routers (includes merged router-level security)
                if has_explicit {
                    for r in &resolved {
                        if !r.merged_security().is_empty() {
                            protected_routes.push(ProtectedRoute {
                                method: r.route_info.method.to_string(),
                                path_pattern: r.full_axum_path(),
                            });
                        }
                    }
                } else {
                    // Collect from inventory
                    for route in inventory::iter::<&RouteInfo> {
                        if !route.security.is_empty() {
                            protected_routes.push(ProtectedRoute {
                                method: route.method.to_string(),
                                path_pattern: route.axum_path.to_string(),
                            });
                        }
                    }
                }

                let protected = Arc::new(protected_routes);

                app = app.layer(axum::middleware::from_fn(
                    move |req: axum::http::Request<axum::body::Body>, next| {
                        let path = req.uri().path().to_string();
                        let method = req.method().clone();
                        let protected = protected.clone();
                        let auth_layer = auth_layer.clone();

                        async move {
                            let is_protected = protected.iter().any(|route| {
                                route_method_matches(&route.method, &method)
                                    && path_matches_pattern(&route.path_pattern, &path)
                            });

                            if is_protected {
                                auth_layer.run(req, next).await
                            } else {
                                next.run(req).await
                            }
                        }
                    },
                ));
            }
        }

        // Add mounted sub-applications
        // For each mounted app, we need to add its routes with the path prefix
        // and set up its own /docs and /openapi.json handlers
        for (path, mut sub_app) in mounted_apps {
            // Get sub-app's resolved routes
            let sub_resolved = sub_app.resolve_routes();
            
            // Add routes with path prefix
            for r in sub_resolved {
                let full_path = format!("{}{}", path, r.full_axum_path());
                let method_router = (r.route_info.method_router_fn)();
                app = app.route(&full_path, method_router);
            }
            
            // Generate sub-app's OpenAPI spec and swagger HTML
            let sub_spec = sub_app.generate_openapi_spec();
            let sub_swagger = sub_app.generate_swagger_html();
            let sub_spec_json = serde_json::to_string_pretty(&sub_spec.to_json_with_query_params(&sub_app.routers))
                .unwrap_or_else(|_| "{}".to_string());
            
            let _sub_path_prefix = path.to_string();
            let sub_spec_json_clone = sub_spec_json.clone();
            app = app.route(
                &format!("{}/openapi.json", path),
                axum::routing::get(move || {
                    let spec = sub_spec_json_clone.clone();
                    async move { (StatusCode::OK, [("content-type", "application/json")], spec) }
                }),
            );
            
            let sub_swagger_clone = sub_swagger.clone();
            app = app.route(
                &format!("{}/docs", path),
                axum::routing::get(move || {
                    let html = sub_swagger_clone.clone();
                    async move { (StatusCode::OK, [("content-type", "text/html")], html) }
                }),
            );
            
            // Add sub-app's ReDoc endpoint
            let sub_redoc = sub_app.generate_redoc_html(&format!("{}/openapi.json", path));
            let sub_redoc_clone = sub_redoc.clone();
            app = app.route(
                &format!("{}/redoc", path),
                axum::routing::get(move || {
                    let html = sub_redoc_clone.clone();
                    async move { (StatusCode::OK, [("content-type", "text/html")], html) }
                }),
            );
            
            // Add sub-app's static files with path prefix
            for (sub_path, dir) in sub_app.static_files.drain(..) {
                let full_path = format!("{}{}", path, sub_path);
                let static_service = tower_http::services::ServeDir::new(dir);
                app = app.nest_service(&full_path, static_service);
            }
        }

        // Apply compression if configured (after all routes are added)
        if let Some(ref compression_config) = self.middleware.compression_config {
            app = app.layer(compression_config.clone().build());
        }

        // Apply GZip compression if configured (FastAPI-compatible)
        if let Some(ref gzip_config) = self.middleware.gzip_config {
            app = app.layer(gzip_config.clone().build());
        }

        // Apply rate limiting if configured
        if let Some(ref rate_limit_config) = self.middleware.rate_limit_config {
            app = app.layer(rate_limit_config.clone().build());
        }

        let mut app = app.with_state(state.clone());

        // Apply panic catching first (so global error handler can see the 500 response)
        if self.catch_panic {
            app = app.layer(tower_http::catch_panic::CatchPanicLayer::new());
        }

        // Apply global error handler (transforms non-success responses)
        if let Some(handler) = self.error_handler.clone() {
            let state_for_handler = state.clone();
            app = app.layer(axum::middleware::from_fn(
                move |req: axum::http::Request<axum::body::Body>, next: axum::middleware::Next| {
                    let handler = handler.clone();
                    let state = state_for_handler.clone();

                    // Create a lightweight request copy for handler context
                    let method = req.method().clone();
                    let uri = req.uri().clone();
                    let headers = req.headers().clone();
                    let ctx_req = {
                        let mut r = axum::http::Request::builder()
                            .method(method)
                            .uri(uri)
                            .body(axum::body::Body::empty())
                            .unwrap();
                        *r.headers_mut() = headers;
                        r
                    };

                    async move {
                        let res = next.run(req).await;
                        if res.status().is_success() || res.status().is_redirection() {
                            return res;
                        }

                        handler(state, ctx_req, Box::new(res.status().as_u16())).await
                    }
                },
            ));
        }

        // Apply response background tasks middleware
        // This executes tasks added via BackgroundTasks dependency after response is sent
        app = app.layer(axum::middleware::from_fn(response_tasks::response_task_middleware));

        // Create lifespan runner
        let lifecycle = self.lifecycle.clone();
        let lifespan_runner = lifespan::LifespanRunner::new(lifecycle, state);

        // Add lifespan layer to the router
        let layer_fn = lifespan_runner.clone().into_layer();
        app = layer_fn(app);

        (app, lifespan_runner)
    }

pub async fn serve(self, addr: &str) {
        // Build router + lifespan runner so that state and hooks are consistent
        // across serve/TestClient/embedded usage.
        let (app, runner) = self.into_router_with_lifespan();

        // Run startup hooks before accepting requests (FastAPI-like behavior).
        runner.ensure_startup().await;

        let listener = tokio::net::TcpListener::bind(addr)
            .await
            .expect("Failed to bind to address");
        println!("🚀 Server running at http://{}", addr);
        println!("📖 Swagger UI available at http://{}/docs", addr);

        // Serve with graceful shutdown
        let runner_for_shutdown = runner.clone();
        axum::serve(listener, app)
            .with_graceful_shutdown(async move {
                // Wait for shutdown signal
                tokio::signal::ctrl_c().await.ok();
                // Run shutdown hooks
                runner_for_shutdown.shutdown().await;
            })
            .await
            .expect("Server error");
    }

    fn build_operation(
        route: &RouteInfo,
        tags: Vec<String>,
        security_list: &[&str],
    ) -> openapi::Operation {
        let description = if route.description.is_empty() {
            None
        } else {
            Some(route.description.to_string())
        };

        let status_code = route.success_status.to_string();

        let security: Vec<HashMap<String, Vec<String>>> = security_list
            .iter()
            .map(|s| {
                let scheme_name = match *s {
                    "bearer" => "bearerAuth",
                    other => other,
                };
                let mut map = HashMap::new();
                map.insert(scheme_name.to_string(), vec![]);
                map
            })
            .collect();

        let schema_ref_value = if route.success_status == 204 {
            None
        } else if route.is_vec_response {
            Some(serde_json::json!({
                "type": "array",
                "items": { "$ref": format!("#/components/schemas/{}", route.vec_inner_type_name) }
            }))
        } else {
            Some(
                serde_json::json!({ "$ref": format!("#/components/schemas/{}", route.response_type_name) }),
            )
        };

        // Get content type (response_model override takes precedence)
        let response_content_type = route
            .response_model_options
            .content_type
            .unwrap_or(route.response_class.content_type());

        // For non-JSON responses, we may not have a schema ref
        let response_schema_ref = if route.response_class == ResponseClass::Json {
            schema_ref_value
        } else {
            None // Non-JSON responses don't have JSON schema refs
        };

        let success_desc = openapi::status_description(route.success_status).to_string();

        // Build external_docs if URL is provided
        let external_docs = route.external_docs_url.map(|url| openapi::ExternalDocs {
            description: route.external_docs_description.map(|s| s.to_string()),
            url: url.to_string(),
        });

        openapi::Operation {
            summary: route.summary.map(|s| s.to_string()).or_else(|| Some(route.handler_name.replace('_', " "))),
            description,
            operation_id: Some(route.handler_name.to_string()),
            tags,
            parameters: route.parameters.to_vec(),
            request_body: if route.has_body {
                Some(openapi::RequestBody {
                    required: true,
                    content_type: "application/json".to_string(),
                    schema_ref: format!("#/components/schemas/{}", route.body_type_name),
                })
            } else {
                None
            },
            responses: {
                let mut map = HashMap::new();
                map.insert(
                    status_code,
                    openapi::ResponseDef {
                        description: success_desc,
                        schema_ref: response_schema_ref,
                        content_type: Some(response_content_type.to_string()),
                    },
                );
                // Error responses are always JSON
                map.insert(
                    "400".to_string(),
                    openapi::ResponseDef {
                        description: "Bad Request".to_string(),
                        schema_ref: Some(
                            serde_json::json!({ "$ref": "#/components/schemas/ApiError" }),
                        ),
                        content_type: Some("application/json".to_string()),
                    },
                );
                if route.is_result_return {
                    map.insert(
                        "404".to_string(),
                        openapi::ResponseDef {
                            description: "Not Found".to_string(),
                            schema_ref: Some(
                                serde_json::json!({ "$ref": "#/components/schemas/ApiError" }),
                            ),
                            content_type: None,
                        },
                    );
                }
                if route.has_body {
                    map.insert(
                        "422".to_string(),
                        openapi::ResponseDef {
                            description: "Validation Failed".to_string(),
                            schema_ref: Some(
                                serde_json::json!({ "$ref": "#/components/schemas/ApiError" }),
                            ),
                            content_type: None,
                        },
                    );
                }
                map.insert(
                    "500".to_string(),
                    openapi::ResponseDef {
                        description: "Internal Server Error".to_string(),
                        schema_ref: Some(
                            serde_json::json!({ "$ref": "#/components/schemas/ApiError" }),
                        ),
                        content_type: None,
                    },
                );
                map
            },
            security,
            callbacks: HashMap::new(),
            deprecated: route.deprecated,
            external_docs,
        }
    }

    fn generate_swagger_html(&self) -> String {
        match &self.swagger_mode {
            SwaggerMode::Cdn(cdn_base) => {
                format!(
                    r#"<!DOCTYPE html>
<html>
<head>
    <title>{title} - Swagger UI</title>
    <link rel="stylesheet" type="text/css" href="{cdn}/swagger-ui.css" >
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="{cdn}/swagger-ui-bundle.js"> </script>
    <script>
    SwaggerUIBundle({{
        url: "/openapi.json",
        dom_id: '#swagger-ui',
        presets: [SwaggerUIBundle.presets.apis, SwaggerUIBundle.SwaggerUIStandalonePreset],
        layout: "BaseLayout"
    }})
    </script>
</body>
</html>"#,
                    title = self.title,
                    cdn = cdn_base,
                )
            }
            SwaggerMode::Embedded => {
                format!(
                    r#"<!DOCTYPE html>
<html>
<head>
    <title>{title} - API Reference</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>{css}</style>
</head>
<body>
    <script id="api-reference" data-url="/openapi.json"></script>
    <script>{js}</script>
</body>
</html>"#,
                    title = self.title,
                    css = include_str!("../assets/scalar.min.css"),
                    js = include_str!("../assets/scalar.min.js"),
                )
            }
        }
    }

    fn generate_redoc_html(&self, spec_path: &str) -> String {
        format!(
            r#"<!DOCTYPE html>
<html>
<head>
    <title>{title} - ReDoc</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.ico">
</head>
<body>
    <redoc spec-url='{spec_path}'></redoc>
    <script src="https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js"></script>
</body>
</html>"#,
            title = self.title,
            spec_path = spec_path,
        )
    }

    fn generate_openapi_spec(&self) -> openapi::OpenApiSpec {
        let mut schemas = HashMap::new();

        // Add ApiError schema
        schemas.insert("ApiError".to_string(), openapi::api_error_schema());

        for info in inventory::iter::<SchemaInfo> {
            schemas.insert(info.name.to_string(), (info.schema_fn)());
            for (nested_name, nested_schema) in (info.nested_fn)() {
                schemas.entry(nested_name).or_insert(nested_schema);
            }
        }

        let mut paths = HashMap::new();
        // When explicit routers are used, `paths` keys are the resolved full path (prefix applied).
        // We keep a mapping so we can attach callbacks to the correct operation.
        let mut explicit_route_paths: HashMap<*const RouteInfo, String> = HashMap::new();

        if self.has_explicit_routes() {
            let resolved = self.resolve_routes();
            for r in &resolved {
                let route = r.route_info;
                let full_path = r.full_path();
                explicit_route_paths.insert(route as *const RouteInfo, full_path.clone());

                let tags = r.merged_tags();
                let sec = r.merged_security();
                let operation = Self::build_operation(route, tags, &sec);
                let path_item = paths.entry(full_path).or_insert_with(HashMap::new);
                path_item.insert(route.method.to_lowercase(), operation);
            }
        } else {
            for route in inventory::iter::<&RouteInfo> {
                let tags: Vec<String> = route.tags.iter().map(|s| s.to_string()).collect();
                let sec: Vec<&str> = route.security.to_vec();
                let operation = Self::build_operation(route, tags, &sec);
                let path_item = paths
                    .entry(route.path.to_string())
                    .or_insert_with(HashMap::new);
                path_item.insert(route.method.to_lowercase(), operation);
            }
        }

        // Merge callbacks into the appropriate operations
        // We need to find the owner route's operation and add the callback to it
        // First, process explicit callbacks (added via .callback() method)
        for (owner, callback_name, expression, callback_route) in &self.callbacks {
            let owner_method = owner.method.to_lowercase();
            let owner_path = if !explicit_route_paths.is_empty() {
                explicit_route_paths
                    .get(&(*owner as *const RouteInfo))
                    .cloned()
                    .unwrap_or_else(|| owner.path.to_string())
            } else {
                owner.path.to_string()
            };

            if let Some(path_item) = paths.get_mut(&owner_path) {
                if let Some(operation) = path_item.get_mut(&owner_method) {
                    // Build the callback operation
                    let callback_tags: Vec<String> = callback_route.tags.iter().map(|s| s.to_string()).collect();
                    let callback_sec: Vec<&str> = callback_route.security.to_vec();
                    let callback_operation = Self::build_operation(callback_route, callback_tags, &callback_sec);
                    
                    // Create the callback PathItem
                    let mut callback_path_item = openapi::PathItem::new();
                    callback_path_item.insert(callback_route.method.to_lowercase(), callback_operation);
                    
                    // Add to operation's callbacks
                    let mut callback = openapi::Callback::new();
                    callback.insert(expression.clone(), callback_path_item);
                    operation.callbacks.insert(callback_name.clone(), callback);
                }
            }
        }

        // Also process inventory-based callbacks (registered via #[callback(...)] attribute)
        for callback_info in inventory::iter::<CallbackInfo> {
            let owner: &RouteInfo = callback_info.owner;
            let callback_name = callback_info.name;
            let expression = callback_info.expression;
            let callback_route = callback_info.route;

            let owner_method = owner.method.to_lowercase();
            let owner_path = if !explicit_route_paths.is_empty() {
                explicit_route_paths
                    .get(&(owner as *const RouteInfo))
                    .cloned()
                    .unwrap_or_else(|| owner.path.to_string())
            } else {
                owner.path.to_string()
            };

            if let Some(path_item) = paths.get_mut(&owner_path) {
                if let Some(operation) = path_item.get_mut(&owner_method) {
                    // Build the callback operation
                    let callback_tags: Vec<String> = callback_route.tags.iter().map(|s| s.to_string()).collect();
                    let callback_sec: Vec<&str> = callback_route.security.to_vec();
                    let callback_operation = Self::build_operation(callback_route, callback_tags, &callback_sec);
                    
                    // Create the callback PathItem
                    let mut callback_path_item = openapi::PathItem::new();
                    callback_path_item.insert(callback_route.method.to_lowercase(), callback_operation);
                    
                    // Add to operation's callbacks
                    let mut callback = openapi::Callback::new();
                    callback.insert(expression.to_string(), callback_path_item);
                    operation.callbacks.insert(callback_name.to_string(), callback);
                }
            }
        }

        openapi::OpenApiSpec {
            openapi: "3.1.0".to_string(),
            info: openapi::Info {
                title: self.title.clone(),
                version: self.version.clone(),
                description: self.description.clone(),
                contact: self.contact.clone(),
                license: self.license.clone(),
            },
            servers: self.servers.clone(),
            paths,
            webhooks: self.webhooks.clone(),
            schemas,
            security_schemes: self.security_schemes.clone(),
        }
    }
}

impl openapi::OpenApiSpec {
    /// Enhanced to_json that includes dynamic query parameters
    pub fn to_json_with_query_params(&self, routers: &[UltraApiRouter]) -> serde_json::Value {
        let mut val = self.to_json();

        // Build path mapping: for each route, determine the actual spec path
        let use_routers = !routers.is_empty();

        struct RoutePathInfo {
            spec_path: String,
            method: String,
            query_params_fn: Option<fn() -> Vec<openapi::DynParameter>>,
        }

        let mut route_paths = Vec::new();

        if use_routers {
            for router in routers {
                let resolved = router.resolve("", &[], &[]);
                for r in &resolved {
                    if let Some(qfn) = r.route_info.query_params_fn {
                        route_paths.push(RoutePathInfo {
                            spec_path: r.full_path(),
                            method: r.route_info.method.to_lowercase(),
                            query_params_fn: Some(qfn),
                        });
                    }
                }
            }
        } else {
            for route in inventory::iter::<&RouteInfo> {
                if let Some(qfn) = route.query_params_fn {
                    route_paths.push(RoutePathInfo {
                        spec_path: route.path.to_string(),
                        method: route.method.to_lowercase(),
                        query_params_fn: Some(qfn),
                    });
                }
            }
        }

        for rp in &route_paths {
            if let Some(qfn) = rp.query_params_fn {
                let dyn_params = qfn();
                if !dyn_params.is_empty() {
                    let escaped = rp.spec_path.replace('~', "~0").replace('/', "~1");
                    let pointer = format!("/paths/{}/{}", escaped, rp.method);
                    if let Some(op) = val.pointer_mut(&pointer) {
                        let params = op
                            .get("parameters")
                            .and_then(|v| v.as_array())
                            .cloned()
                            .unwrap_or_default();
                        let mut all_params = params;
                        for dp in &dyn_params {
                            let mut schema = serde_json::json!({ "type": dp.schema_type });
                            if let Some(v) = dp.minimum {
                                schema["minimum"] = serde_json::json!(v);
                            }
                            if let Some(v) = dp.maximum {
                                schema["maximum"] = serde_json::json!(v);
                            }
                            if let Some(v) = dp.min_length {
                                schema["minLength"] = serde_json::json!(v);
                            }
                            if let Some(v) = dp.max_length {
                                schema["maxLength"] = serde_json::json!(v);
                            }
                            if let Some(v) = &dp.pattern {
                                schema["pattern"] = serde_json::json!(v);
                            }
                            let mut param = serde_json::json!({
                                "name": dp.name,
                                "in": dp.location,
                                "required": dp.required,
                                "schema": schema
                            });
                            if let Some(desc) = &dp.description {
                                param["description"] = serde_json::Value::String(desc.clone());
                            }
                            all_params.push(param);
                        }
                        op["parameters"] = serde_json::Value::Array(all_params);
                    }
                }
            }
        }

        val
    }
}

// Backward compatibility aliases (deprecated, use UltraApiApp and UltraApiRouter)
#[allow(deprecated)]
pub use UltraApiApp as HayaiApp;
#[allow(deprecated)]
pub use UltraApiRouter as HayaiRouter;
