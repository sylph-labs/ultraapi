pub mod grpc;
pub mod lifespan;
pub mod middleware;
pub mod openapi;

use axum::http::{Method, StatusCode};
use axum::response::{IntoResponse, Response};
use axum::Router;
use serde::Serialize;
use std::any::{Any, TypeId};
use std::collections::HashMap;
use std::sync::Arc;

use lifespan::Lifecycle;
use middleware::MiddlewareBuilder;

// Re-exports
pub use axum;
pub use axum_extra;
pub use inventory;
pub use regex;
pub use schemars;
pub use serde;
pub use serde_json;
pub use tokio_stream;
pub use ultraapi_macros::{api_model, delete, get, post, put};

pub mod prelude {
    pub use crate::axum;
    pub use crate::inventory;
    pub use crate::schemars;
    pub use crate::serde;
    pub use crate::{
        lifespan::Lifecycle,
        middleware::{CorsConfig, MiddlewareBuilder},
    };
    pub use crate::{sse_data, sse_event};
    pub use crate::{ApiError, Depends, Dep, Generator, ResponseClass, Scope, State, UltraApiApp, UltraApiRouter, Validate, YieldDep, DependencyScope, ResponseModelOptions};
    pub use axum::extract::{Form, Multipart, Query};
    pub use axum_extra::extract::{CookieJar, TypedHeader};
    pub use ultraapi_macros::{api_model, delete, get, post, put, sse, ws};
}

/// SSE helper macros
#[macro_export]
macro_rules! sse_data {
    ($data:expr) => {
        axum::sse::Event::default().data($data)
    };
    ($($arg:tt)*) => {
        axum::sse::Event::default().data(format!($($arg)*))
    };
}

/// Create an SSE event with custom event type
#[macro_export]
macro_rules! sse_event {
    ($event_type:expr, $data:expr) => {
        axum::sse::Event::default()
            .event($event_type)
            .data($data)
    };
    ($event_type:expr, $($arg:tt)*) => {
        axum::sse::Event::default()
            .event($event_type)
            .data(format!($($arg)*))
    };
}

/// Validation trait generated by api_model attribute
pub trait Validate {
    fn validate(&self) -> Result<(), Vec<String>>;
}

impl Validate for () {
    fn validate(&self) -> Result<(), Vec<String>> {
        Ok(())
    }
}

#[async_trait::async_trait]
pub trait AsyncValidate: Send + Sync {
    async fn validate_async(&self, _state: &AppState) -> Result<(), Vec<String>> {
        Ok(())
    }
}

#[async_trait::async_trait]
impl AsyncValidate for () {
    async fn validate_async(&self, _state: &AppState) -> Result<(), Vec<String>> {
        Ok(())
    }
}

#[macro_export]
macro_rules! impl_async_validate {
    ($ty:ty, $sync_fn:ident) => {
        #[async_trait::async_trait]
        impl $crate::AsyncValidate for $ty {
            async fn validate_async(&self, _state: &$crate::AppState) -> Result<(), Vec<String>> {
                $sync_fn(self)
            }
        }
    };
}

/// Trait for schema patches from validation attributes
#[doc(hidden)]
pub trait HasSchemaPatches {
    fn patch_schema(props: &mut HashMap<String, openapi::PropertyPatch>);
}

/// Application state holding dependency injection container
#[derive(Clone)]
pub struct AppState {
    deps: Arc<HashMap<TypeId, Arc<dyn Any + Send + Sync>>>,
    /// Optional resolver for Depends function-based dependencies
    depends_resolver: Option<Arc<DependsResolver>>,
}

impl Default for AppState {
    fn default() -> Self {
        Self::new()
    }
}

impl AppState {
    pub fn new() -> Self {
        Self {
            deps: Arc::new(HashMap::new()),
            depends_resolver: None,
        }
    }

    /// Get a registered dependency
    pub fn get<T: 'static + Send + Sync>(&self) -> Option<Arc<T>> {
        self.deps
            .get(&TypeId::of::<T>())
            .and_then(|v| v.clone().downcast::<T>().ok())
    }

    /// Get the Depends resolver if available
    pub fn get_depends_resolver(&self) -> Option<&Arc<DependsResolver>> {
        self.depends_resolver.as_ref()
    }

    /// Set the Depends resolver
    pub fn set_depends_resolver(&mut self, resolver: Arc<DependsResolver>) {
        self.depends_resolver = Some(resolver);
    }
}

/// Dependency injection extractor
pub struct Dep<T: 'static + Send + Sync>(Arc<T>);

impl<T: 'static + Send + Sync> Dep<T> {
    pub fn from_app_state(state: &AppState) -> Result<Self, ApiError> {
        state.get::<T>().map(Dep).ok_or_else(|| {
            ApiError::internal(format!(
                "Dependency not registered: {}",
                std::any::type_name::<T>()
            ))
        })
    }
}

impl<T: 'static + Send + Sync> std::ops::Deref for Dep<T> {
    type Target = T;
    fn deref(&self) -> &T {
        &self.0
    }
}

/// Axum-style state extractor â€” alternative to Dep<T>
/// Both work identically; choose based on your preferred style.
pub struct State<T: 'static + Send + Sync>(Arc<T>);

impl<T: 'static + Send + Sync> State<T> {
    pub fn from_app_state(state: &AppState) -> Result<Self, ApiError> {
        state.get::<T>().map(State).ok_or_else(|| {
            ApiError::internal(format!(
                "State not registered: {}",
                std::any::type_name::<T>()
            ))
        })
    }
}

impl<T: 'static + Send + Sync> std::ops::Deref for State<T> {
    type Target = T;
    fn deref(&self) -> &T {
        &self.0
    }
}

// =============================================================================
// FastAPI-compatible Depends function-based dependency injection
// =============================================================================

/// Scope for yield-based dependencies (FastAPI-style)
///
/// - `Function`: cleanup runs before response is returned
/// - `Request`: cleanup runs after response handling completes
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum Scope {
    /// Cleanup runs before the handler returns its response
    #[default]
    Function,
    /// Cleanup runs after the entire request handling completes
    Request,
}

/// Trait for yield-based generators with cleanup hooks (FastAPI-style).
///
/// Implementors yield a value, then run cleanup when the scope ends.
/// This is similar to FastAPI's `yield` dependencies.
///
/// # Example
///
/// ```ignore
/// struct DatabaseConnection { ... }
///
/// impl Generator for DatabaseConnection {
///     type Output = Self;
///     type Error = DependencyError;
///
///     fn generate(
///         self: Arc<Self>,
///         scope: Scope,
///     ) -> impl Future<Output = Result<Self::Output, Self::Error>> + Send {
///         async move {
///             // Setup: connect to database
///             Ok(DatabaseConnection { ... })
///         }
///     }
///
///     fn cleanup(self: Arc<Self>) -> impl Future<Output = Result<(), DependencyError>> + Send {
///         async move {
///             // Cleanup: close connection
///             Ok(())
///         }
///     }
/// }
/// ```
/// 
/// For type-erased usage in DependsResolver (internal)
/// Uses boxed futures to be dyn-compatible
#[async_trait::async_trait]
pub trait DynGenerator: Send + Sync + 'static {
    /// Generate the dependency value
    fn generate(
        self: Arc<Self>,
        scope: Scope,
    ) -> std::pin::Pin<Box<dyn Future<Output = Result<Arc<dyn std::any::Any + Send + Sync>, DependencyError>> + Send>>;

    /// Cleanup hook called when the scope ends
    fn cleanup(self: Arc<Self>) -> std::pin::Pin<Box<dyn Future<Output = Result<(), DependencyError>> + Send>>;
}

/// Blanket implementation for any Generator<T>
#[async_trait::async_trait]
impl<T, G> DynGenerator for G
where
    T: Send + Sync + 'static,
    G: Generator<Output = T, Error = DependencyError> + Send + Sync + 'static,
{
    fn generate(
        self: Arc<Self>,
        scope: Scope,
    ) -> std::pin::Pin<Box<dyn Future<Output = Result<Arc<dyn std::any::Any + Send + Sync>, DependencyError>> + Send>> {
        let result = Generator::generate(self.clone(), scope);
        Box::pin(async move {
            let output = result.await?;
            // Wrap in a new Arc of type-erased Any
            Ok(Arc::new(Erased(output)) as Arc<dyn std::any::Any + Send + Sync>)
        })
    }

    fn cleanup(self: Arc<Self>) -> std::pin::Pin<Box<dyn Future<Output = Result<(), DependencyError>> + Send>> {
        let result = Generator::cleanup(self.clone());
        Box::pin(result)
    }
}

/// Internal type for wrapping generator outputs
struct Erased<T: ?Sized>(T);

/// Marker trait for yield-based generators (FastAPI-style).
///
/// Implementors yield a value, then run cleanup when the scope ends.
/// 
/// # Example
///
/// ```ignore
/// use ultraapi::prelude::*;
/// use std::sync::Arc;
///
/// struct DatabasePool {
///     connection_string: String,
/// }
///
/// #[async_trait::async_trait]
/// impl Generator for DatabasePool {
///     type Output = Self;
///     type Error = DependencyError;
///
///     async fn generate(self: Arc<Self>, _scope: Scope) -> Result<Self::Output, Self::Error> {
///         Ok(Arc::try_unwrap(self).unwrap_or_else(|a| (*a).clone()))
///     }
///
///     async fn cleanup(self: Arc<Self>) -> Result<(), Self::Error> {
///         println!("Cleaning up database pool");
///         Ok(())
///     }
/// }
/// ```
#[async_trait::async_trait]
pub trait Generator: Send + Sync + 'static {
    /// The type yielded by the generator
    type Output: Send + Sync;
    /// Error type if generation or cleanup fails
    type Error: std::fmt::Display + Send + Sync;

    /// Generate the dependency value
    async fn generate(
        self: Arc<Self>,
        scope: Scope,
    ) -> Result<Self::Output, Self::Error>;

    /// Cleanup hook called when the scope ends
    async fn cleanup(self: Arc<Self>) -> Result<(), Self::Error>;
}

/// Wrapper for yield-based dependencies with automatic cleanup
pub struct YieldDep<G: Generator> {
    generator: Arc<G>,
    value: Option<Arc<G::Output>>,
    scope: Scope,
}

impl<G: Generator> YieldDep<G> {
    /// Create a new yield dependency
    pub fn new(generator: Arc<G>, scope: Scope) -> Self {
        Self {
            generator,
            value: None,
            scope,
        }
    }

    /// Resolve the dependency (call generate)
    pub async fn resolve(&mut self) -> Result<Arc<G::Output>, DependencyError> {
        let value = self.generator.clone().generate(self.scope).await
            .map_err(|e| DependencyError {
                dependency: std::any::type_name::<G>().to_string(),
                message: e.to_string(),
                chain: vec![],
            })?;
        
        let arc_value = Arc::new(value);
        self.value = Some(arc_value.clone());
        Ok(arc_value)
    }

    /// Get the resolved value
    pub fn get(&self) -> Option<&Arc<G::Output>> {
        self.value.as_ref()
    }

    /// Run cleanup (call the generator's cleanup)
    pub async fn cleanup(&mut self) -> Result<(), DependencyError> {
        if let Some(value) = self.value.take() {
            // We need to reconstruct the generator with the value for cleanup
            // For simplicity, we'll use the generator directly
            self.generator.clone().cleanup().await
                .map_err(|e| DependencyError {
                    dependency: std::any::type_name::<G>().to_string(),
                    message: format!("Cleanup failed: {}", e),
                    chain: vec![],
                })?;
        }
        Ok(())
    }

    /// Get the scope
    pub fn scope(&self) -> Scope {
        self.scope
    }
}

/// Request-level state for tracking yield dependency cleanup hooks
#[derive(Clone, Default)]
pub struct DependencyScope {
    /// Function-scoped cleanup hooks (run before response)
    function_hooks: Arc<parking_lot::Mutex<Vec<Box<dyn FnOnce() + Send + Sync>>>>,
    /// Request-scoped cleanup hooks (run after response)
    request_hooks: Arc<parking_lot::Mutex<Vec<Box<dyn FnOnce() + Send + Sync>>>>,
}

impl DependencyScope {
    /// Create a new dependency scope
    pub fn new() -> Self {
        Self::default()
    }

    /// Register a cleanup hook for function scope
    pub fn add_function_hook<F>(&self, hook: F)
    where
        F: FnOnce() + Send + Sync + 'static,
    {
        self.function_hooks.lock().push(Box::new(hook));
    }

    /// Register a cleanup hook for request scope
    pub fn add_request_hook<F>(&self, hook: F)
    where
        F: FnOnce() + Send + Sync + 'static,
    {
        self.request_hooks.lock().push(Box::new(hook));
    }

    /// Run all function-scope cleanup hooks
    /// Returns the first error encountered, if any
    pub async fn run_function_cleanup(&self) {
        let mut hooks = self.function_hooks.lock();
        for hook in hooks.drain(..) {
            hook();
        }
    }

    /// Run all request-scope cleanup hooks
    /// Returns the first error encountered, if any
    pub async fn run_request_cleanup(&self) {
        let mut hooks = self.request_hooks.lock();
        for hook in hooks.drain(..) {
            hook();
        }
    }
}

/// Error type for dependency injection failures
#[derive(Debug, Clone, Serialize)]
pub struct DependencyError {
    pub dependency: String,
    pub message: String,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub chain: Vec<String>,
}

impl DependencyError {
    pub fn missing(dependency: &str) -> Self {
        Self {
            dependency: dependency.to_string(),
            message: format!("Dependency not found: {}", dependency),
            chain: vec![],
        }
    }

    pub fn cycle(dependency: &str, chain: Vec<String>) -> Self {
        Self {
            dependency: dependency.to_string(),
            message: format!("Circular dependency detected: {}", dependency),
            chain,
        }
    }

    pub fn missing_with_chain(dependency: &str, chain: Vec<String>) -> Self {
        Self {
            dependency: dependency.to_string(),
            message: format!("Dependency not found in chain: {}", dependency),
            chain,
        }
    }
}

impl std::fmt::Display for DependencyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)?;
        if !self.chain.is_empty() {
            write!(f, " (chain: {})", self.chain.join(" -> "))?;
        }
        Ok(())
    }
}

impl std::error::Error for DependencyError {}

/// Marker struct for Depends - represents a resolved dependency value
pub struct Depends<T: Send + Sync>(pub Arc<T>);

impl<T: 'static + Send + Sync> Depends<T> {
    pub fn from_app_state(_state: &AppState) -> Result<Self, ApiError> {
        // This is the fallback - actual resolution happens via DependsResolver
        // The macro-generated code uses DependsResolver for proper nested resolution
        Err(ApiError::internal(
            "Depends resolver not properly initialized".to_string(),
        ))
    }
}

impl<T: 'static + Send + Sync> std::ops::Deref for Depends<T> {
    type Target = T;
    fn deref(&self) -> &T {
        &self.0
    }
}

/// Internal: Wrapper for dependency functions that stores metadata
struct DependsFunc {
    name: &'static str,
    // Store the function using type erasure with Arc
    func: Arc<dyn Fn(AppState) -> std::pin::Pin<Box<dyn Future<Output = Result<Box<dyn std::any::Any + Send + Sync>, DependencyError>> + Send>> + Send + Sync>,
    output_type_name: &'static str,
}

/// Thread-safe resolver for Depends dependencies with cycle detection
pub struct DependsResolver {
    // Map from TypeId to the registered dependency function
    deps: parking_lot::RwLock<HashMap<TypeId, DependsFunc>>,
    // Map from TypeId to registered generator (yield-based dependencies)
    generators: parking_lot::RwLock<HashMap<TypeId, GeneratorRegistryEntry>>,
    // Map from TypeId to dependency chain info (what deps this dependency needs)
    dep_chains: parking_lot::RwLock<HashMap<TypeId, Vec<TypeId>>>,
}

/// Entry for a registered generator
#[derive(Clone)]
struct GeneratorRegistryEntry {
    name: &'static str,
    generator: Arc<dyn DynGenerator + Send + Sync>,
    scope: Scope,
}

impl Default for DependsResolver {
    fn default() -> Self {
        Self::new()
    }
}

impl DependsResolver {
    pub fn new() -> Self {
        Self {
            deps: parking_lot::RwLock::new(HashMap::new()),
            generators: parking_lot::RwLock::new(HashMap::new()),
            dep_chains: parking_lot::RwLock::new(HashMap::new()),
        }
    }

    /// Register a yield-based dependency (generator with cleanup)
    /// 
    /// The generator will be called to produce the dependency value,
    /// and its cleanup will be called based on the specified scope.
    pub fn register_yield<T, G>(&self, _marker: std::marker::PhantomData<T>, generator: G, scope: Scope)
    where
        T: Send + Sync + 'static,
        G: Generator<Output = T, Error = DependencyError> + Send + Sync + 'static,
    {
        let name = std::any::type_name::<T>();
        
        // Wrap the generator using the blanket impl of DynGenerator
        let wrapped: Arc<dyn DynGenerator + Send + Sync> = Arc::new(generator);
        
        let mut generators = self.generators.write();
        generators.insert(
            TypeId::of::<T>(),
            GeneratorRegistryEntry {
                name,
                generator: wrapped,
                scope,
            },
        );
    }

    /// Check if a type is registered as a generator
    pub fn is_generator<T: 'static>(&self) -> bool {
        self.generators.read().contains_key(&TypeId::of::<T>())
    }

    /// Get the scope for a registered generator
    pub fn get_generator_scope<T: 'static>(&self) -> Option<Scope> {
        self.generators.read()
            .get(&TypeId::of::<T>())
            .map(|entry| entry.scope)
    }

    /// Resolve a generator dependency and register cleanup hooks
    pub async fn resolve_generator<T: 'static + Send + Sync>(
        &self,
        state: &AppState,
        dependency_scope: &DependencyScope,
    ) -> Result<Arc<dyn std::any::Any + Send + Sync>, DependencyError> {
        let entry = self.generators.read()
            .get(&TypeId::of::<T>())
            .cloned()
            .ok_or_else(|| DependencyError::missing(std::any::type_name::<T>()))?;
        
        let generator = entry.generator.clone();
        let scope = entry.scope;

        // Generate the value
        let value = generator.clone().generate(scope).await
            .map_err(|e| DependencyError {
                dependency: entry.name.to_string(),
                message: e.to_string(),
                chain: vec![],
            })?;

        // Register cleanup based on scope
        let generator_for_cleanup = generator.clone();
        match scope {
            Scope::Function => {
                dependency_scope.add_function_hook(move || {
                    // Run cleanup synchronously for function scope (can't use async here)
                    // In practice, we'd need a runtime to run async cleanup
                    // For simplicity, we'll note that async cleanup should use spawn
                    let gen = generator_for_cleanup.clone();
                    tokio::spawn(async move {
                        let _ = gen.cleanup().await;
                    });
                });
            }
            Scope::Request => {
                dependency_scope.add_request_hook(move || {
                    let gen = generator_for_cleanup.clone();
                    tokio::spawn(async move {
                        let _ = gen.cleanup().await;
                    });
                });
            }
        }

        Ok(value)
    }

    /// Register a dependency function
    pub fn register<T, F, R>(&self, _marker: std::marker::PhantomData<T>, func: F)
    where
        T: Send + Sync + 'static,
        F: Fn(AppState) -> R + Send + Sync + 'static,
        R: Future<Output = Result<T, DependencyError>> + Send + 'static,
    {
        let name = std::any::type_name::<T>();
        let output_type_name = name;

        let func_arc: Arc<dyn Fn(AppState) -> std::pin::Pin<Box<dyn Future<Output = Result<Box<dyn std::any::Any + Send + Sync>, DependencyError>> + Send>> + Send + Sync> = Arc::new(move |state: AppState| {
            let future = func(state);
            Box::pin(async move {
                match future.await {
                    Ok(val) => Ok(Box::new(val) as Box<dyn std::any::Any + Send + Sync>),
                    Err(e) => Err(e),
                }
            })
        });

        let mut deps = self.deps.write();
        deps.insert(
            TypeId::of::<T>(),
            DependsFunc {
                name,
                func: func_arc,
                output_type_name,
            },
        );
    }

    /// Resolve a dependency with cycle detection
    pub async fn resolve<T: 'static + Send + Sync>(
        &self,
        state: &AppState,
    ) -> Result<Arc<T>, DependencyError> {
        // Track resolution chain for cycle detection
        let mut visiting: std::collections::HashSet<TypeId> = std::collections::HashSet::new();
        self.resolve_recursive::<T>(state, &mut visiting).await
    }

    async fn resolve_recursive<T: 'static + Send + Sync>(
        &self,
        state: &AppState,
        visiting: &mut std::collections::HashSet<TypeId>,
    ) -> Result<Arc<T>, DependencyError> {
        let type_id = TypeId::of::<T>();

        // Cycle detection: if we're already visiting this type in the current chain
        if visiting.contains(&type_id) {
            let chain: Vec<String> = visiting
                .iter()
                .map(|tid| {
                    // Find the dependency name (best effort)
                    let deps = self.deps.read();
                    for (registered_tid, func) in deps.iter() {
                        if registered_tid == tid {
                            return func.name.to_string();
                        }
                    }
                    format!("{:?}", tid)
                })
                .chain(std::iter::once(std::any::type_name::<T>().to_string()))
                .collect();

            return Err(DependencyError::cycle(std::any::type_name::<T>(), chain));
        }

        // Mark as visiting
        visiting.insert(type_id);

        // First, check if there are any nested dependencies registered via register_with_deps
        // and resolve them first. This enables dependency chaining.
        {
            let chains = self.dep_chains.read();
            if let Some(deps) = chains.get(&type_id) {
                // We have registered deps - in a full implementation, we'd resolve them here
                // For now, we store the dependency chain info and let the function access
                // pre-resolved deps from AppState
                let _deps = deps.clone(); // Placeholder for nested resolution
            }
        }

        // First, try to get from AppState (backward compatibility with Dep<T>/State<T>)
        if let Some(dep) = state.get::<T>() {
            visiting.remove(&type_id);
            return Ok(dep);
        }

        // Try to resolve via registered Depends function
        let deps = self.deps.read();
        if let Some(func) = deps.get(&type_id) {
            let func = Arc::clone(&func.func);
            drop(deps); // Release lock before async call

            // Call the function to resolve the dependency
            let boxed_result = (func)(state.clone()).await;

            // Check for cycles after resolution
            visiting.remove(&type_id);

            // Convert Box<dyn Any + Send + Sync> to Arc<T>
            match boxed_result {
                Ok(boxed) => {
                    match boxed.downcast::<T>() {
                        Ok(t) => Ok(Arc::new(*t)),
                        Err(_) => Err(DependencyError::missing(std::any::type_name::<T>())),
                    }
                }
                Err(e) => Err(e),
            }
        } else {
            visiting.remove(&type_id);
            Err(DependencyError::missing(std::any::type_name::<T>()))
        }
    }

    /// Register a dependency function along with its dependency chain info.
    /// 
    /// This enables automatic resolution of nested dependencies. When resolving,
    /// the resolver will first resolve any dependencies listed in `depends_on`.
    /// 
    /// # Example
    /// 
    /// ```ignore
    /// use ultraapi::prelude::*;
    /// use std::sync::Arc;
    /// 
    /// #[derive(Clone)]
    /// struct DbPool { connection_string: String }
    /// 
    /// #[derive(Clone)]
    /// struct UserRepository { pool: Arc<DbPool> }
    /// 
    /// // A dependency that needs another dependency
    /// async fn get_user_repo(state: AppState) -> Result<Arc<UserRepository>, DependencyError> {
    ///     let pool = state.get::<DbPool>().ok_or_else(|| DependencyError::missing("DbPool"))?;
    ///     Ok(Arc::new(UserRepository { pool }))
    /// }
    /// 
    /// // Register with dependency chain info
    /// resolver.register_with_deps(
    ///     std::marker::PhantomData::<UserRepository>,
    ///     get_user_repo,
    ///     vec![TypeId::of::<DbPool>()],  // UserRepository depends on DbPool
    /// );
    /// ```
    pub fn register_with_deps<T, F, R>(&self, _marker: std::marker::PhantomData<T>, func: F, depends_on: Vec<TypeId>)
    where
        T: Send + Sync + 'static,
        F: Fn(AppState) -> R + Send + Sync + 'static,
        R: Future<Output = Result<T, DependencyError>> + Send + 'static,
    {
        // First register the function
        self.register(std::marker::PhantomData::<T>, func);
        
        // Then register the dependency chain info
        let mut chains = self.dep_chains.write();
        chains.insert(TypeId::of::<T>(), depends_on);
    }

    /// Check if a type has registered dependencies
    pub fn has_deps<T: 'static>(&self) -> bool {
        self.dep_chains.read().contains_key(&TypeId::of::<T>())
    }

    /// Get the registered dependencies for a type
    pub fn get_deps<T: 'static>(&self) -> Option<Vec<TypeId>> {
        self.dep_chains.read().get(&TypeId::of::<T>()).cloned()
    }
}

// Re-export for convenience
pub use std::future::Future;

/// API Error type
#[derive(Debug, Serialize)]
pub struct ApiError {
    #[serde(skip)]
    pub status: StatusCode,
    pub error: String,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub details: Vec<String>,
}

impl ApiError {
    pub fn unauthorized(msg: impl Into<String>) -> Self {
        Self {
            status: StatusCode::UNAUTHORIZED,
            error: msg.into(),
            details: vec![],
        }
    }

    pub fn bad_request(msg: String) -> Self {
        Self {
            status: StatusCode::BAD_REQUEST,
            error: msg,
            details: vec![],
        }
    }

    pub fn forbidden(msg: impl Into<String>) -> Self {
        Self {
            status: StatusCode::FORBIDDEN,
            error: msg.into(),
            details: vec![],
        }
    }

    pub fn not_found(msg: String) -> Self {
        Self {
            status: StatusCode::NOT_FOUND,
            error: msg,
            details: vec![],
        }
    }

    pub fn internal(msg: String) -> Self {
        Self {
            status: StatusCode::INTERNAL_SERVER_ERROR,
            error: msg,
            details: vec![],
        }
    }

    pub fn validation_error(errors: Vec<String>) -> Self {
        Self {
            status: StatusCode::UNPROCESSABLE_ENTITY,
            error: "Validation failed".into(),
            details: errors,
        }
    }
}

impl IntoResponse for ApiError {
    fn into_response(self) -> Response {
        let body = serde_json::to_string(&self)
            .unwrap_or_else(|_| r#"{"error":"Internal server error"}"#.to_string());
        (self.status, [("content-type", "application/json")], body).into_response()
    }
}

/// Route information collected by proc macros
/// Response model shaping options for FastAPI-like response_model control
#[derive(Clone)]
pub struct ResponseModelOptions {
    /// Fields to include in the response (takes precedence over exclude)
    pub include: Option<Vec<&'static str>>,
    /// Fields to exclude from the response
    pub exclude: Option<Vec<&'static str>>,
    /// Whether to use alias names (from serde(rename)) for serialization
    pub by_alias: bool,
}

impl Default for ResponseModelOptions {
    fn default() -> Self {
        ResponseModelOptions {
            include: None,
            exclude: None,
            by_alias: false,
        }
    }
}

/// Response class types for specifying different response content types
/// Similar to FastAPI's response_class parameter
#[derive(Clone, Debug, PartialEq, Eq)]
pub enum ResponseClass {
    /// Default JSON response (application/json)
    Json,
    /// HTML response (text/html)
    Html,
    /// Plain text response (text/plain)
    Text,
    /// Binary/octet-stream response (application/octet-stream)
    Binary,
    /// Streaming response (application/octet-stream with chunked transfer)
    Stream,
    /// XML response (application/xml)
    Xml,
}

impl Default for ResponseClass {
    fn default() -> Self {
        ResponseClass::Json
    }
}

impl ResponseClass {
    /// Get the content-type header value for this response class
    pub fn content_type(&self) -> &'static str {
        match self {
            ResponseClass::Json => "application/json",
            ResponseClass::Html => "text/html",
            ResponseClass::Text => "text/plain",
            ResponseClass::Binary => "application/octet-stream",
            ResponseClass::Stream => "application/octet-stream",
            ResponseClass::Xml => "application/xml",
        }
    }
}

impl ResponseModelOptions {
    /// Apply response model shaping to a serde_json::Value
    pub fn apply(&self, value: serde_json::Value) -> serde_json::Value {
        match value {
            serde_json::Value::Object(map) => {
                let mut result = serde_json::Map::new();
                
                for (key, val) in map {
                    let should_include = match (&self.include, &self.exclude) {
                        // If include is specified, only include those fields
                        (Some(include_list), _) => include_list.contains(&key.as_str()),
                        // If only exclude is specified, exclude listed fields
                        (None, Some(exclude_list)) => !exclude_list.contains(&key.as_str()),
                        // No filtering
                        (None, None) => true,
                    };
                    
                    if should_include {
                        // Recursively apply to nested objects
                        result.insert(key, self.apply(val));
                    }
                }
                
                serde_json::Value::Object(result)
            }
            // For arrays, apply to each element
            serde_json::Value::Array(arr) => {
                serde_json::Value::Array(arr.into_iter().map(|v| self.apply(v)).collect())
            }
            // Other values pass through unchanged
            other => other,
        }
    }
}

pub struct RouteInfo {
    pub path: &'static str,
    pub axum_path: &'static str,
    pub method: &'static str,
    pub handler_name: &'static str,
    pub response_type_name: &'static str,
    pub is_result_return: bool,
    pub is_vec_response: bool,
    pub is_sse: bool,
    pub is_websocket: bool,
    pub vec_inner_type_name: &'static str,
    pub parameters: &'static [openapi::Parameter],
    pub has_body: bool,
    pub body_type_name: &'static str,
    pub success_status: u16,
    pub description: &'static str,
    pub tags: &'static [&'static str],
    pub security: &'static [&'static str],
    pub query_params_fn: Option<fn() -> Vec<openapi::DynParameter>>,
    /// Response model shaping options (include/exclude/by_alias)
    pub response_model_options: ResponseModelOptions,
    /// Response class for content-type (json, html, text, binary, stream, xml)
    pub response_class: ResponseClass,
    /// Operation summary (short description for OpenAPI)
    pub summary: Option<&'static str>,
    /// Mark route as deprecated in OpenAPI spec
    pub deprecated: bool,
    /// External documentation URL for this route
    pub external_docs_url: Option<&'static str>,
    /// External documentation description
    pub external_docs_description: Option<&'static str>,
    pub register_fn: fn(Router<AppState>) -> Router<AppState>,
    pub method_router_fn: fn() -> axum::routing::MethodRouter<AppState>,
}

inventory::collect!(&'static RouteInfo);

#[derive(Clone)]
struct ProtectedRoute {
    method: String,
    path_pattern: String,
}

fn is_path_param_segment(segment: &str) -> bool {
    segment.starts_with('{') && segment.ends_with('}')
}

fn path_matches_pattern(pattern: &str, path: &str) -> bool {
    let normalized_pattern = pattern.trim_end_matches('/');
    let normalized_path = path.trim_end_matches('/');

    let pattern_segments: Vec<&str> = normalized_pattern
        .split('/')
        .filter(|s| !s.is_empty())
        .collect();
    let path_segments: Vec<&str> = normalized_path
        .split('/')
        .filter(|s| !s.is_empty())
        .collect();

    if pattern_segments.len() != path_segments.len() {
        return false;
    }

    pattern_segments
        .iter()
        .zip(path_segments.iter())
        .all(|(segment_pattern, segment_path)| {
            is_path_param_segment(segment_pattern) || segment_pattern == segment_path
        })
}

fn route_method_matches(route_method: &str, request_method: &Method) -> bool {
    if route_method.eq_ignore_ascii_case(request_method.as_str()) {
        return true;
    }

    // Axum automatically supports HEAD for GET routes.
    request_method == Method::HEAD && route_method.eq_ignore_ascii_case(Method::GET.as_str())
}

/// Schema information collected by api_model attribute
pub struct SchemaInfo {
    pub name: &'static str,
    pub schema_fn: fn() -> openapi::Schema,
    pub nested_fn: fn() -> std::collections::HashMap<String, openapi::Schema>,
}

inventory::collect!(SchemaInfo);

/// A resolved route with runtime prefix and merged tags/security
pub struct ResolvedRoute {
    pub route_info: &'static RouteInfo,
    pub prefix: String,
    pub extra_tags: Vec<String>,
    pub extra_security: Vec<String>,
}

impl ResolvedRoute {
    /// Full path = prefix + route's original path
    pub fn full_path(&self) -> String {
        let base = self.route_info.path;
        if self.prefix.is_empty() {
            base.to_string()
        } else {
            format!("{}{}", self.prefix, base)
        }
    }

    /// Full axum path = prefix + route's original axum_path
    pub fn full_axum_path(&self) -> String {
        let base = self.route_info.axum_path;
        if self.prefix.is_empty() {
            base.to_string()
        } else {
            format!("{}{}", self.prefix, base)
        }
    }

    /// Merged tags: router-level + route-level
    pub fn merged_tags(&self) -> Vec<String> {
        let mut tags: Vec<String> = self.extra_tags.clone();
        for t in self.route_info.tags {
            if !tags.contains(&t.to_string()) {
                tags.push(t.to_string());
            }
        }
        tags
    }

    /// Merged security: router-level + route-level
    pub fn merged_security(&self) -> Vec<&str> {
        let mut sec: Vec<&str> = self.extra_security.iter().map(|s| s.as_str()).collect();
        for s in self.route_info.security {
            if !sec.contains(s) {
                sec.push(s);
            }
        }
        sec
    }
}

/// A FastAPI-style router with prefix, shared tags, security, deps, and nested routers
pub struct UltraApiRouter {
    prefix: String,
    routes: Vec<&'static RouteInfo>,
    tags: Vec<String>,
    security: Vec<String>,
    deps: HashMap<TypeId, Arc<dyn Any + Send + Sync>>,
    children: Vec<UltraApiRouter>,
}

impl UltraApiRouter {
    pub fn new(prefix: &str) -> Self {
        Self {
            prefix: prefix.to_string(),
            routes: Vec::new(),
            tags: Vec::new(),
            security: Vec::new(),
            deps: HashMap::new(),
            children: Vec::new(),
        }
    }

    pub fn route(mut self, route: &'static RouteInfo) -> Self {
        self.routes.push(route);
        self
    }

    pub fn tag(mut self, tag: &str) -> Self {
        self.tags.push(tag.to_string());
        self
    }

    pub fn security(mut self, scheme: &str) -> Self {
        self.security.push(scheme.to_string());
        self
    }

    pub fn dep<T: 'static + Send + Sync>(mut self, dep: T) -> Self {
        self.deps.insert(TypeId::of::<T>(), Arc::new(dep));
        self
    }

    pub fn include(mut self, child: UltraApiRouter) -> Self {
        self.children.push(child);
        self
    }

    /// Flatten this router tree into resolved routes, accumulating prefix/tags/security
    pub fn resolve(
        &self,
        parent_prefix: &str,
        parent_tags: &[String],
        parent_security: &[String],
    ) -> Vec<ResolvedRoute> {
        let full_prefix = format!("{}{}", parent_prefix, self.prefix);
        let mut merged_tags: Vec<String> = parent_tags.to_vec();
        for t in &self.tags {
            if !merged_tags.contains(t) {
                merged_tags.push(t.clone());
            }
        }
        let mut merged_security: Vec<String> = parent_security.to_vec();
        for s in &self.security {
            if !merged_security.contains(s) {
                merged_security.push(s.clone());
            }
        }

        let mut resolved = Vec::new();
        for route in &self.routes {
            resolved.push(ResolvedRoute {
                route_info: route,
                prefix: full_prefix.clone(),
                extra_tags: merged_tags.clone(),
                extra_security: merged_security.clone(),
            });
        }
        for child in &self.children {
            resolved.extend(child.resolve(&full_prefix, &merged_tags, &merged_security));
        }
        resolved
    }

    /// Collect all deps from this router tree
    pub fn collect_deps(&self) -> HashMap<TypeId, Arc<dyn Any + Send + Sync>> {
        let mut all = self.deps.clone();
        for child in &self.children {
            all.extend(child.collect_deps());
        }
        all
    }
}

/// Swagger UI serving mode
#[derive(Debug, Clone)]
pub enum SwaggerMode {
    /// Load Swagger UI assets from a CDN URL
    Cdn(String),
    /// Use embedded Scalar API reference (works offline)
    Embedded,
}

/// The main application struct
pub struct UltraApiApp {
    deps: HashMap<TypeId, Arc<dyn Any + Send + Sync>>,
    /// Dependency overrides for testing - these take precedence over regular deps
    dep_overrides: HashMap<TypeId, Arc<dyn Any + Send + Sync>>,
    /// Resolver for Depends function-based dependencies
    depends_resolver: Option<Arc<DependsResolver>>,
    title: String,
    version: String,
    description: Option<String>,
    contact: Option<openapi::Contact>,
    license: Option<openapi::License>,
    swagger_mode: SwaggerMode,
    servers: Vec<openapi::Server>,
    security_schemes: HashMap<String, openapi::SecurityScheme>,
    routers: Vec<UltraApiRouter>,
    /// Middleware configuration
    middleware: MiddlewareBuilder,
    /// Lifecycle hooks (startup/shutdown)
    lifecycle: Lifecycle,
}

impl Default for UltraApiApp {
    fn default() -> Self {
        Self::new()
    }
}

impl UltraApiApp {
    pub fn new() -> Self {
        Self {
            deps: HashMap::new(),
            dep_overrides: HashMap::new(),
            depends_resolver: None,
            title: env!("CARGO_PKG_NAME").to_string(),
            version: env!("CARGO_PKG_VERSION").to_string(),
            description: None,
            contact: None,
            license: None,
            swagger_mode: SwaggerMode::Embedded,
            servers: Vec::new(),
            security_schemes: HashMap::new(),
            routers: Vec::new(),
            middleware: MiddlewareBuilder::new(),
            lifecycle: Lifecycle::new(),
        }
    }

    pub fn title(mut self, title: &str) -> Self {
        self.title = title.to_string();
        self
    }

    pub fn version(mut self, version: &str) -> Self {
        self.version = version.to_string();
        self
    }

    pub fn description(mut self, desc: &str) -> Self {
        self.description = Some(desc.to_string());
        self
    }

    pub fn contact(mut self, name: &str, email: &str, url: &str) -> Self {
        self.contact = Some(openapi::Contact {
            name: Some(name.to_string()),
            email: Some(email.to_string()),
            url: Some(url.to_string()),
        });
        self
    }

    pub fn license(mut self, name: &str, url: &str) -> Self {
        self.license = Some(openapi::License {
            name: name.to_string(),
            url: Some(url.to_string()),
        });
        self
    }

    pub fn swagger_mode(mut self, mode: SwaggerMode) -> Self {
        self.swagger_mode = mode;
        self
    }

    pub fn swagger_cdn(mut self, url: &str) -> Self {
        self.swagger_mode = SwaggerMode::Cdn(url.to_string());
        self
    }

    pub fn dep<T: 'static + Send + Sync>(mut self, dep: T) -> Self {
        self.deps.insert(TypeId::of::<T>(), Arc::new(dep));
        self
    }

    /// Override a dependency for testing.
    ///
    /// This allows replacing registered dependencies with mock values during testing.
    /// Overrides take precedence over regular dependencies registered via [`dep()`](UltraApiApp::dep).
    ///
    /// # Example
    ///
    /// ```
    /// use ultraapi::prelude::*;
    ///
    /// #[derive(Clone)]
    /// struct DatabasePool {
    ///     dsn: &'static str,
    /// }
    ///
    /// // Use the same type to replace runtime dependency with a test stub.
    /// let app = UltraApiApp::new()
    ///     .dep(DatabasePool { dsn: "postgres://prod" })
    ///     .override_dep(DatabasePool { dsn: "sqlite://:memory:" });
    ///
    /// assert!(app.has_override::<DatabasePool>());
    /// ```
    pub fn override_dep<T: 'static + Send + Sync>(mut self, dep: T) -> Self {
        self.dep_overrides.insert(TypeId::of::<T>(), Arc::new(dep));
        self
    }

    /// Check if a dependency override exists for the given type.
    pub fn has_override<T: 'static + Send + Sync>(&self) -> bool {
        self.dep_overrides.contains_key(&TypeId::of::<T>())
    }

    /// Clear all dependency overrides.
    pub fn clear_overrides(mut self) -> Self {
        self.dep_overrides.clear();
        self
    }

    /// Register a function-based dependency (FastAPI-style Depends).
    ///
    /// The function will be called to resolve the dependency at request time,
    /// with support for nested dependencies through the `Depends` parameter.
    ///
    /// # Example
    ///
    /// ```ignore
    /// use ultraapi::prelude::*;
    ///
    /// // Define a simple dependency function
    /// async fn get_db_pool(state: AppState) -> Result<Arc<DbPool>, DependencyError> {
    ///     state.get::<DbPool>().ok_or_else(|| DependencyError::missing("DbPool"))
    /// }
    ///
    /// // Define a nested dependency that depends on the first
    /// async fn get_user_service(pool: Depends<DbPool>) -> Result<Arc<UserService>, DependencyError> {
    ///     Ok(Arc::new(UserService { pool: (*pool).clone() }))
    /// }
    ///
    /// let app = UltraApiApp::new()
    ///     .dep(DbPool { connection_string: "postgres://localhost".into() })
    ///     .depends(get_db_pool)
    ///     .depends(get_user_service);
    /// ```
    pub fn depends<T, F, R>(mut self, func: F) -> Self
    where
        T: Send + Sync + 'static,
        F: Fn(AppState) -> R + Send + Sync + 'static,
        R: Future<Output = Result<T, DependencyError>> + Send + 'static,
    {
        // Create resolver if not exists
        if self.depends_resolver.is_none() {
            self.depends_resolver = Some(Arc::new(DependsResolver::new()));
        }

        if let Some(ref resolver) = self.depends_resolver {
            let resolver = Arc::clone(resolver);
            resolver.register(std::marker::PhantomData::<T>, func);
        }

        self
    }

    /// Register a callable dependency function that declares its dependencies.
    ///
    /// This enables FastAPI-like dependency chaining where a dependency function
    /// can declare what other dependencies it needs via the `depends_on` parameter.
    ///
    /// # Example
    ///
    /// ```ignore
    /// use ultraapi::prelude::*;
    /// use std::sync::Arc;
    /// use std::any::TypeId;
    ///
    /// #[derive(Clone)]
    /// struct DbPool { connection_string: String }
    ///
    /// #[derive(Clone)]
    /// struct UserRepository { pool: Arc<DbPool> }
    ///
    /// // A dependency that needs another dependency
    /// async fn get_user_repo(state: AppState) -> Result<Arc<UserRepository>, DependencyError> {
    ///     let pool = state.get::<DbPool>().ok_or_else(|| DependencyError::missing("DbPool"))?;
    ///     Ok(Arc::new(UserRepository { pool }))
    /// }
    ///
    /// let app = UltraApiApp::new()
    ///     .dep(DbPool { connection_string: "postgres://localhost".into() })
    ///     .depends_with_deps(get_user_repo, vec![TypeId::of::<DbPool>()]);
    /// ```
    pub fn depends_with_deps<T, F, R>(mut self, func: F, depends_on: Vec<TypeId>) -> Self
    where
        T: Send + Sync + 'static,
        F: Fn(AppState) -> R + Send + Sync + 'static,
        R: Future<Output = Result<T, DependencyError>> + Send + 'static,
    {
        // Create resolver if not exists
        if self.depends_resolver.is_none() {
            self.depends_resolver = Some(Arc::new(DependsResolver::new()));
        }

        if let Some(ref resolver) = self.depends_resolver {
            let resolver = Arc::clone(resolver);
            resolver.register_with_deps(std::marker::PhantomData::<T>, func, depends_on);
        }

        self
    }

    /// Register a yield-based dependency (FastAPI-style generator with cleanup).
    ///
    /// The generator produces a value and runs cleanup when the scope ends.
    /// This is similar to FastAPI's `yield` dependencies.
    ///
    /// # Example
    ///
    /// ```ignore
    /// use ultraapi::prelude::*;
    /// use std::sync::Arc;
    ///
    /// struct DatabasePool {
    ///     connection_string: String,
    /// }
    ///
    /// // Implement Generator for the dependency type
    /// #[async_trait::async_trait]
    /// impl Generator<dyn Any + Send + Sync, Output = Arc<dyn Any + Send + Sync>, Error = DependencyError> for DatabasePool {
    ///     async fn generate(self: Arc<Self>, _scope: Scope) -> Result<Arc<dyn Any + Send + Sync>, DependencyError> {
    ///         Ok(self.clone() as Arc<dyn Any + Send + Sync>)
    ///     }
    ///
    ///     async fn cleanup(self: Arc<Self>) -> Result<(), DependencyError> {
    ///         println!("Cleaning up database pool");
    ///         Ok(())
    ///     }
    /// }
    ///
    /// let app = UltraApiApp::new()
    ///     .yield_depends(Arc::new(DatabasePool { connection_string: "postgres://localhost".into() }), Scope::Request);
    /// ```
    pub fn yield_depends<T, G>(mut self, generator: G, scope: Scope) -> Self
    where
        T: Send + Sync + 'static,
        G: Generator<Output = T, Error = DependencyError> + Send + Sync + 'static,
    {
        // Create resolver if not exists
        if self.depends_resolver.is_none() {
            self.depends_resolver = Some(Arc::new(DependsResolver::new()));
        }

        if let Some(ref resolver) = self.depends_resolver {
            let resolver = Arc::clone(resolver);
            resolver.register_yield(std::marker::PhantomData::<T>, generator, scope);
        }

        self
    }

    /// Get the Depends resolver (for internal use)
    pub fn get_depends_resolver(&self) -> Option<&Arc<DependsResolver>> {
        self.depends_resolver.as_ref()
    }

    pub fn server(mut self, url: &str) -> Self {
        self.servers.push(openapi::Server {
            url: url.to_string(),
        });
        self
    }

    pub fn security_scheme(mut self, name: &str, scheme: openapi::SecurityScheme) -> Self {
        self.security_schemes.insert(name.to_string(), scheme);
        self
    }

    pub fn bearer_auth(self) -> Self {
        self.security_scheme(
            "bearerAuth",
            openapi::SecurityScheme::Bearer {
                bearer_format: None,
            },
        )
    }

    /// Add OAuth2 security scheme with implicit flow
    ///
    /// # Example
    /// ```
    /// use ultraapi::prelude::*;
    ///
    /// let app = UltraApiApp::new()
    ///     .oauth2_implicit(
    ///         "oauth2Implicit",
    ///         "https://example.com/authorize",
    ///         [
    ///             ("read", "Read access"),
    ///             ("write", "Write access"),
    ///         ],
    ///     );
    /// ```
    pub fn oauth2_implicit<'a>(
        mut self,
        name: &str,
        authorization_url: &str,
        scopes: impl IntoIterator<Item = (&'a str, &'a str)>,
    ) -> Self {
        let mut scope_map = std::collections::HashMap::new();
        for (key, desc) in scopes {
            scope_map.insert(key.to_string(), desc.to_string());
        }
        let flow = openapi::OAuth2Flow {
            authorization_url: Some(authorization_url.to_string()),
            token_url: None,
            refresh_url: None,
            scopes: scope_map,
        };
        let mut flows = openapi::OAuth2Flows::default();
        flows.implicit = Some(flow);
        self.security_schemes.insert(
            name.to_string(),
            openapi::SecurityScheme::OAuth2(flows),
        );
        self
    }

    /// Add OAuth2 security scheme with password flow
    ///
    /// # Example
    /// ```
    /// use ultraapi::prelude::*;
    ///
    /// let app = UltraApiApp::new()
    ///     .oauth2_password(
    ///         "oauth2Password",
    ///         "https://example.com/token",
    ///         [
    ///             ("read", "Read access"),
    ///             ("write", "Write access"),
    ///         ],
    ///     );
    /// ```
    pub fn oauth2_password<'a>(
        mut self,
        name: &str,
        token_url: &str,
        scopes: impl IntoIterator<Item = (&'a str, &'a str)>,
    ) -> Self {
        let mut scope_map = std::collections::HashMap::new();
        for (key, desc) in scopes {
            scope_map.insert(key.to_string(), desc.to_string());
        }
        let flow = openapi::OAuth2Flow {
            authorization_url: None,
            token_url: Some(token_url.to_string()),
            refresh_url: None,
            scopes: scope_map,
        };
        let mut flows = openapi::OAuth2Flows::default();
        flows.password = Some(flow);
        self.security_schemes.insert(
            name.to_string(),
            openapi::SecurityScheme::OAuth2(flows),
        );
        self
    }

    /// Add OAuth2 security scheme with client credentials flow
    ///
    /// # Example
    /// ```
    /// use ultraapi::prelude::*;
    ///
    /// let app = UltraApiApp::new()
    ///     .oauth2_client_credentials(
    ///         "oauth2ClientCredentials",
    ///         "https://example.com/token",
    ///         [
    ///             ("read", "Read access"),
    ///             ("write", "Write access"),
    ///         ],
    ///     );
    /// ```
    pub fn oauth2_client_credentials<'a>(
        mut self,
        name: &str,
        token_url: &str,
        scopes: impl IntoIterator<Item = (&'a str, &'a str)>,
    ) -> Self {
        let mut scope_map = std::collections::HashMap::new();
        for (key, desc) in scopes {
            scope_map.insert(key.to_string(), desc.to_string());
        }
        let flow = openapi::OAuth2Flow {
            authorization_url: None,
            token_url: Some(token_url.to_string()),
            refresh_url: None,
            scopes: scope_map,
        };
        let mut flows = openapi::OAuth2Flows::default();
        flows.client_credentials = Some(flow);
        self.security_schemes.insert(
            name.to_string(),
            openapi::SecurityScheme::OAuth2(flows),
        );
        self
    }

    /// Add OAuth2 security scheme with authorization code flow
    ///
    /// # Example
    /// ```
    /// use ultraapi::prelude::*;
    ///
    /// let app = UltraApiApp::new()
    ///     .oauth2_authorization_code(
    ///         "oauth2AuthCode",
    ///         "https://example.com/authorize",
    ///         "https://example.com/token",
    ///         [
    ///             ("read", "Read access"),
    ///             ("write", "Write access"),
    ///         ],
    ///     );
    /// ```
    pub fn oauth2_authorization_code<'a>(
        mut self,
        name: &str,
        authorization_url: &str,
        token_url: &str,
        scopes: impl IntoIterator<Item = (&'a str, &'a str)>,
    ) -> Self {
        let mut scope_map = std::collections::HashMap::new();
        for (key, desc) in scopes {
            scope_map.insert(key.to_string(), desc.to_string());
        }
        let flow = openapi::OAuth2Flow {
            authorization_url: Some(authorization_url.to_string()),
            token_url: Some(token_url.to_string()),
            refresh_url: None,
            scopes: scope_map,
        };
        let mut flows = openapi::OAuth2Flows::default();
        flows.authorization_code = Some(flow);
        self.security_schemes.insert(
            name.to_string(),
            openapi::SecurityScheme::OAuth2(flows),
        );
        self
    }

    /// Add OAuth2 security scheme with multiple flows
    ///
    /// # Example
    /// ```
    /// use ultraapi::prelude::*;
    /// use ultraapi::openapi::{OAuth2Flow, OAuth2Flows};
    ///
    /// let mut flows = OAuth2Flows::default();
    /// flows.authorization_code = Some(OAuth2Flow {
    ///     authorization_url: Some("https://example.com/authorize".to_string()),
    ///     token_url: Some("https://example.com/token".to_string()),
    ///     refresh_url: None,
    ///     scopes: [("read".to_string(), "Read access".to_string())].into(),
    /// });
    ///
    /// let app = UltraApiApp::new()
    ///     .oauth2("oauth2Multi", flows);
    /// ```
    pub fn oauth2(mut self, name: &str, flows: openapi::OAuth2Flows) -> Self {
        self.security_schemes
            .insert(name.to_string(), openapi::SecurityScheme::OAuth2(flows));
        self
    }

    /// Add OpenID Connect security scheme
    ///
    /// # Example
    /// ```
    /// use ultraapi::prelude::*;
    ///
    /// let app = UltraApiApp::new()
    ///     .openid_connect("oidc", "https://example.com/.well-known/openid-configuration");
    /// ```
    pub fn openid_connect(mut self, name: &str, url: &str) -> Self {
        self.security_schemes.insert(
            name.to_string(),
            openapi::SecurityScheme::OpenIdConnect {
                url: url.to_string(),
            },
        );
        self
    }

    /// Add API key security scheme
    ///
    /// # Example
    /// ```
    /// use ultraapi::prelude::*;
    ///
    /// let app = UltraApiApp::new()
    ///     .api_key("apiKeyAuth", "X-API-Key", "header");
    /// ```
    pub fn api_key(mut self, name: &str, key_name: &str, location: &str) -> Self {
        self.security_schemes.insert(
            name.to_string(),
            openapi::SecurityScheme::ApiKey {
                name: key_name.to_string(),
                location: location.to_string(),
            },
        );
        self
    }

    pub fn include(mut self, router: UltraApiRouter) -> Self {
        self.routers.push(router);
        self
    }

    /// Configure middleware for the application
    ///
    /// # Example
    /// ```
    /// use ultraapi::prelude::*;
    ///
    /// let app = UltraApiApp::new()
    ///     .middleware(|builder| {
    ///         builder
    ///             .enable_auth()  // Enforce #[security] routes
    ///             .cors(CorsConfig::new())
    ///     });
    /// ```
    pub fn middleware<F>(mut self, f: F) -> Self
    where
        F: FnOnce(MiddlewareBuilder) -> MiddlewareBuilder,
    {
        self.middleware = f(MiddlewareBuilder::new());
        self
    }

    /// Configure lifecycle hooks (startup/shutdown)
    ///
    /// # Example
    /// ```
    /// use ultraapi::prelude::*;
    ///
    /// let app = UltraApiApp::new()
    ///     .lifecycle(|lifecycle| {
    ///         lifecycle
    ///             .on_startup(|state| {
    ///                 Box::pin(async {
    ///                     println!("Starting up!");
    ///                 })
    ///             })
    ///             .on_shutdown(|state| {
    ///                 Box::pin(async {
    ///                     println!("Shutting down!");
    ///                 })
    ///             })
    ///     });
    /// ```
    pub fn lifecycle<F>(mut self, f: F) -> Self
    where
        F: FnOnce(Lifecycle) -> Lifecycle,
    {
        self.lifecycle = f(Lifecycle::new());
        self
    }

    /// Get a reference to the lifecycle hooks
    pub fn lifecycle_hooks(&self) -> &Lifecycle {
        &self.lifecycle
    }

    /// Check if routers were explicitly included
    pub fn has_explicit_routes(&self) -> bool {
        !self.routers.is_empty()
    }

    /// Resolve all routes from included routers
    pub fn resolve_routes(&self) -> Vec<ResolvedRoute> {
        let mut resolved = Vec::new();
        for router in &self.routers {
            resolved.extend(router.resolve("", &[], &[]));
        }
        resolved
    }

    pub fn into_router(self) -> Router {
        let spec = self.generate_openapi_spec();
        let swagger_html = self.generate_swagger_html();
        let has_explicit = self.has_explicit_routes();
        let resolved = if has_explicit {
            self.resolve_routes()
        } else {
            Vec::new()
        };
        let spec_json =
            serde_json::to_string_pretty(&spec.to_json_with_query_params(&self.routers))
                .expect("Failed to serialize OpenAPI spec");

        // Merge deps from routers
        let mut all_deps = self.deps;
        for router in &self.routers {
            all_deps.extend(router.collect_deps());
        }

        // Apply dependency overrides (they take precedence over regular deps)
        for (type_id, override_val) in self.dep_overrides {
            all_deps.insert(type_id, override_val);
        }

        // Store the depends resolver for later use
        let depends_resolver = self.depends_resolver;

        let state = AppState {
            deps: Arc::new(all_deps),
            depends_resolver,
        };

        let mut app = Router::new();

        if has_explicit {
            for r in &resolved {
                let axum_path = r.full_axum_path();
                let method_router = (r.route_info.method_router_fn)();
                app = app.route(&axum_path, method_router);
            }
        } else {
            for route in inventory::iter::<&RouteInfo> {
                app = (route.register_fn)(app);
            }
        }

        let spec_json_clone = spec_json.clone();
        app = app.route(
            "/openapi.json",
            axum::routing::get(move || {
                let spec = spec_json_clone.clone();
                async move { (StatusCode::OK, [("content-type", "application/json")], spec) }
            }),
        );

        app = app.route(
            "/docs",
            axum::routing::get(move || {
                let html = swagger_html.clone();
                async move { (StatusCode::OK, [("content-type", "text/html")], html) }
            }),
        );

        // Apply CORS if configured
        if let Some(ref cors_config) = self.middleware.cors_config {
            app = app.layer(cors_config.clone().build());
        }

        // Apply auth middleware if enabled
        if self.middleware.auth_enabled {
            if let Some(auth_layer) = self.middleware.auth_layer.clone() {
                let mut protected_routes: Vec<ProtectedRoute> = Vec::new();

                // Collect protected routes from explicit routers (includes merged router-level security)
                if has_explicit {
                    for r in &resolved {
                        if !r.merged_security().is_empty() {
                            protected_routes.push(ProtectedRoute {
                                method: r.route_info.method.to_string(),
                                path_pattern: r.full_axum_path(),
                            });
                        }
                    }
                } else {
                    // Collect from inventory
                    for route in inventory::iter::<&RouteInfo> {
                        if !route.security.is_empty() {
                            protected_routes.push(ProtectedRoute {
                                method: route.method.to_string(),
                                path_pattern: route.axum_path.to_string(),
                            });
                        }
                    }
                }

                let protected = Arc::new(protected_routes);

                app = app.layer(axum::middleware::from_fn(
                    move |req: axum::http::Request<axum::body::Body>, next| {
                        let path = req.uri().path().to_string();
                        let method = req.method().clone();
                        let protected = protected.clone();
                        let auth_layer = auth_layer.clone();

                        async move {
                            let is_protected = protected.iter().any(|route| {
                                route_method_matches(&route.method, &method)
                                    && path_matches_pattern(&route.path_pattern, &path)
                            });

                            if is_protected {
                                auth_layer.run(req, next).await
                            } else {
                                next.run(req).await
                            }
                        }
                    },
                ));
            }
        }

        app.with_state(state)
    }

    pub async fn serve(self, addr: &str) {
        // Clone needed fields before consuming self
        let depends_resolver = self.depends_resolver.clone();
        let lifecycle = self.lifecycle.clone();

        let mut all_deps = self.deps.clone();
        for router in &self.routers {
            all_deps.extend(router.collect_deps());
        }
        for (type_id, override_val) in &self.dep_overrides {
            all_deps.insert(*type_id, override_val.clone());
        }

        let state = AppState {
            deps: Arc::new(all_deps),
            depends_resolver,
        };

        // Run startup hooks
        lifecycle.run_startup(&state).await;

        let app = self.into_router();

        let listener = tokio::net::TcpListener::bind(addr)
            .await
            .expect("Failed to bind to address");
        println!("ðŸš€ Server running at http://{}", addr);
        println!("ðŸ“– Swagger UI available at http://{}/docs", addr);

        // Serve with graceful shutdown
        let lifecycle_for_shutdown = lifecycle;
        axum::serve(listener, app)
            .with_graceful_shutdown(async move {
                // Wait for shutdown signal
                tokio::signal::ctrl_c().await.ok();
                // Run shutdown hooks
                lifecycle_for_shutdown.run_shutdown(&state).await;
            })
            .await
            .expect("Server error");
    }

    fn build_operation(
        route: &RouteInfo,
        tags: Vec<String>,
        security_list: &[&str],
    ) -> openapi::Operation {
        let description = if route.description.is_empty() {
            None
        } else {
            Some(route.description.to_string())
        };

        let status_code = route.success_status.to_string();

        let security: Vec<HashMap<String, Vec<String>>> = security_list
            .iter()
            .map(|s| {
                let scheme_name = match *s {
                    "bearer" => "bearerAuth",
                    other => other,
                };
                let mut map = HashMap::new();
                map.insert(scheme_name.to_string(), vec![]);
                map
            })
            .collect();

        let schema_ref_value = if route.success_status == 204 {
            None
        } else if route.is_vec_response {
            Some(serde_json::json!({
                "type": "array",
                "items": { "$ref": format!("#/components/schemas/{}", route.vec_inner_type_name) }
            }))
        } else {
            Some(
                serde_json::json!({ "$ref": format!("#/components/schemas/{}", route.response_type_name) }),
            )
        };

        // Get content type based on response_class
        let response_content_type = route.response_class.content_type();

        // For non-JSON responses, we may not have a schema ref
        let response_schema_ref = if route.response_class == ResponseClass::Json {
            schema_ref_value
        } else {
            None // Non-JSON responses don't have JSON schema refs
        };

        let success_desc = openapi::status_description(route.success_status).to_string();

        // Build external_docs if URL is provided
        let external_docs = route.external_docs_url.map(|url| openapi::ExternalDocs {
            description: route.external_docs_description.map(|s| s.to_string()),
            url: url.to_string(),
        });

        openapi::Operation {
            summary: route.summary.map(|s| s.to_string()).or_else(|| Some(route.handler_name.replace('_', " "))),
            description,
            operation_id: Some(route.handler_name.to_string()),
            tags,
            parameters: route.parameters.to_vec(),
            request_body: if route.has_body {
                Some(openapi::RequestBody {
                    required: true,
                    content_type: "application/json".to_string(),
                    schema_ref: format!("#/components/schemas/{}", route.body_type_name),
                })
            } else {
                None
            },
            responses: {
                let mut map = HashMap::new();
                map.insert(
                    status_code,
                    openapi::ResponseDef {
                        description: success_desc,
                        schema_ref: response_schema_ref,
                        content_type: Some(response_content_type.to_string()),
                    },
                );
                // Error responses are always JSON
                map.insert(
                    "400".to_string(),
                    openapi::ResponseDef {
                        description: "Bad Request".to_string(),
                        schema_ref: Some(
                            serde_json::json!({ "$ref": "#/components/schemas/ApiError" }),
                        ),
                        content_type: Some("application/json".to_string()),
                    },
                );
                if route.is_result_return {
                    map.insert(
                        "404".to_string(),
                        openapi::ResponseDef {
                            description: "Not Found".to_string(),
                            schema_ref: Some(
                                serde_json::json!({ "$ref": "#/components/schemas/ApiError" }),
                            ),
                            content_type: None,
                        },
                    );
                }
                if route.has_body {
                    map.insert(
                        "422".to_string(),
                        openapi::ResponseDef {
                            description: "Validation Failed".to_string(),
                            schema_ref: Some(
                                serde_json::json!({ "$ref": "#/components/schemas/ApiError" }),
                            ),
                            content_type: None,
                        },
                    );
                }
                map.insert(
                    "500".to_string(),
                    openapi::ResponseDef {
                        description: "Internal Server Error".to_string(),
                        schema_ref: Some(
                            serde_json::json!({ "$ref": "#/components/schemas/ApiError" }),
                        ),
                        content_type: None,
                    },
                );
                map
            },
            security,
            callbacks: HashMap::new(),
            deprecated: route.deprecated,
            external_docs,
        }
    }

    fn generate_swagger_html(&self) -> String {
        match &self.swagger_mode {
            SwaggerMode::Cdn(cdn_base) => {
                format!(
                    r#"<!DOCTYPE html>
<html>
<head>
    <title>{title} - Swagger UI</title>
    <link rel="stylesheet" type="text/css" href="{cdn}/swagger-ui.css" >
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="{cdn}/swagger-ui-bundle.js"> </script>
    <script>
    SwaggerUIBundle({{
        url: "/openapi.json",
        dom_id: '#swagger-ui',
        presets: [SwaggerUIBundle.presets.apis, SwaggerUIBundle.SwaggerUIStandalonePreset],
        layout: "BaseLayout"
    }})
    </script>
</body>
</html>"#,
                    title = self.title,
                    cdn = cdn_base,
                )
            }
            SwaggerMode::Embedded => {
                format!(
                    r#"<!DOCTYPE html>
<html>
<head>
    <title>{title} - API Reference</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>{css}</style>
</head>
<body>
    <script id="api-reference" data-url="/openapi.json"></script>
    <script>{js}</script>
</body>
</html>"#,
                    title = self.title,
                    css = include_str!("../assets/scalar.min.css"),
                    js = include_str!("../assets/scalar.min.js"),
                )
            }
        }
    }

    fn generate_openapi_spec(&self) -> openapi::OpenApiSpec {
        let mut schemas = HashMap::new();

        // Add ApiError schema
        schemas.insert("ApiError".to_string(), openapi::api_error_schema());

        for info in inventory::iter::<SchemaInfo> {
            schemas.insert(info.name.to_string(), (info.schema_fn)());
            for (nested_name, nested_schema) in (info.nested_fn)() {
                schemas.entry(nested_name).or_insert(nested_schema);
            }
        }

        let mut paths = HashMap::new();

        if self.has_explicit_routes() {
            let resolved = self.resolve_routes();
            for r in &resolved {
                let route = r.route_info;
                let full_path = r.full_path();
                let tags = r.merged_tags();
                let sec = r.merged_security();
                let operation = Self::build_operation(route, tags, &sec);
                let path_item = paths.entry(full_path).or_insert_with(HashMap::new);
                path_item.insert(route.method.to_lowercase(), operation);
            }
        } else {
            for route in inventory::iter::<&RouteInfo> {
                let tags: Vec<String> = route.tags.iter().map(|s| s.to_string()).collect();
                let sec: Vec<&str> = route.security.to_vec();
                let operation = Self::build_operation(route, tags, &sec);
                let path_item = paths
                    .entry(route.path.to_string())
                    .or_insert_with(HashMap::new);
                path_item.insert(route.method.to_lowercase(), operation);
            }
        }

        openapi::OpenApiSpec {
            openapi: "3.1.0".to_string(),
            info: openapi::Info {
                title: self.title.clone(),
                version: self.version.clone(),
                description: self.description.clone(),
                contact: self.contact.clone(),
                license: self.license.clone(),
            },
            servers: self.servers.clone(),
            paths,
            webhooks: HashMap::new(),
            schemas,
            security_schemes: self.security_schemes.clone(),
        }
    }
}

impl openapi::OpenApiSpec {
    /// Enhanced to_json that includes dynamic query parameters
    pub fn to_json_with_query_params(&self, routers: &[UltraApiRouter]) -> serde_json::Value {
        let mut val = self.to_json();

        // Build path mapping: for each route, determine the actual spec path
        let use_routers = !routers.is_empty();

        struct RoutePathInfo {
            spec_path: String,
            method: String,
            query_params_fn: Option<fn() -> Vec<openapi::DynParameter>>,
        }

        let mut route_paths = Vec::new();

        if use_routers {
            for router in routers {
                let resolved = router.resolve("", &[], &[]);
                for r in &resolved {
                    if let Some(qfn) = r.route_info.query_params_fn {
                        route_paths.push(RoutePathInfo {
                            spec_path: r.full_path(),
                            method: r.route_info.method.to_lowercase(),
                            query_params_fn: Some(qfn),
                        });
                    }
                }
            }
        } else {
            for route in inventory::iter::<&RouteInfo> {
                if let Some(qfn) = route.query_params_fn {
                    route_paths.push(RoutePathInfo {
                        spec_path: route.path.to_string(),
                        method: route.method.to_lowercase(),
                        query_params_fn: Some(qfn),
                    });
                }
            }
        }

        for rp in &route_paths {
            if let Some(qfn) = rp.query_params_fn {
                let dyn_params = qfn();
                if !dyn_params.is_empty() {
                    let escaped = rp.spec_path.replace('~', "~0").replace('/', "~1");
                    let pointer = format!("/paths/{}/{}", escaped, rp.method);
                    if let Some(op) = val.pointer_mut(&pointer) {
                        let params = op
                            .get("parameters")
                            .and_then(|v| v.as_array())
                            .cloned()
                            .unwrap_or_default();
                        let mut all_params = params;
                        for dp in &dyn_params {
                            let mut schema = serde_json::json!({ "type": dp.schema_type });
                            if let Some(v) = dp.minimum {
                                schema["minimum"] = serde_json::json!(v);
                            }
                            if let Some(v) = dp.maximum {
                                schema["maximum"] = serde_json::json!(v);
                            }
                            if let Some(v) = dp.min_length {
                                schema["minLength"] = serde_json::json!(v);
                            }
                            if let Some(v) = dp.max_length {
                                schema["maxLength"] = serde_json::json!(v);
                            }
                            if let Some(v) = &dp.pattern {
                                schema["pattern"] = serde_json::json!(v);
                            }
                            let mut param = serde_json::json!({
                                "name": dp.name,
                                "in": dp.location,
                                "required": dp.required,
                                "schema": schema
                            });
                            if let Some(desc) = &dp.description {
                                param["description"] = serde_json::Value::String(desc.clone());
                            }
                            all_params.push(param);
                        }
                        op["parameters"] = serde_json::Value::Array(all_params);
                    }
                }
            }
        }

        val
    }
}

// Backward compatibility aliases (deprecated, use UltraApiApp and UltraApiRouter)
#[allow(deprecated)]
pub use UltraApiApp as HayaiApp;
#[allow(deprecated)]
pub use UltraApiRouter as HayaiRouter;
